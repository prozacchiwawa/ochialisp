// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Srcloc = require("./srcloc.js");
var $$String = require("bs-platform/lib/js/string.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var BigInteger = require("@pckilgore/bs-biginteger/lib/js/src/BigInteger.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var BigInteger$1 = require("big-integer");

function location_of(l) {
  if (l.TAG === /* Nil */0) {
    return l._0;
  } else {
    return l._0[0];
  }
}

function make_cons(ext, a, b) {
  return {
          TAG: /* Cons */1,
          _0: [
            Curry._2(ext, location_of(a), location_of(b)),
            a,
            b
          ]
        };
}

function matches_integral(s) {
  var is_hex = function (param) {
    if (s.length >= 2) {
      return $$String.sub(s, 0, 2) === "0x";
    } else {
      return false;
    }
  };
  var is_dec = function (param) {
    var dec = true;
    for(var i = 0 ,i_finish = s.length; i < i_finish; ++i){
      var match = Caml_string.get(s, i);
      if (match > 57 || match < 48) {
        dec = false;
      }
      
    }
    return dec;
  };
  if (is_hex(undefined)) {
    return /* Hex */1;
  } else if (is_dec(undefined)) {
    return /* Decimal */0;
  } else {
    return /* NotIntegral */2;
  }
}

function normalize_int(v, base) {
  return BigInteger.toString(BigInteger$1(v, base), 10, undefined);
}

function make_atom(l, v) {
  var alen = v.length;
  if (alen > 1 && Caml_string.get(v, 0) === /* '#' */35) {
    return {
            TAG: /* Atom */4,
            _0: [
              l,
              $$String.sub(v, 1, alen - 1 | 0)
            ]
          };
  }
  var match = matches_integral(v);
  switch (match) {
    case /* Decimal */0 :
        return {
                TAG: /* Integer */2,
                _0: [
                  l,
                  normalize_int(v, 10)
                ]
              };
    case /* Hex */1 :
        return {
                TAG: /* Integer */2,
                _0: [
                  l,
                  normalize_int($$String.sub(v, 2, alen - 2 | 0), 16)
                ]
              };
    case /* NotIntegral */2 :
        return {
                TAG: /* Atom */4,
                _0: [
                  l,
                  v
                ]
              };
    
  }
}

function emit(a, p) {
  return {
          TAG: /* PEmit */1,
          _0: [
            a,
            p
          ]
        };
}

function error(l, t) {
  return {
          TAG: /* PError */2,
          _0: [
            l,
            t
          ]
        };
}

function resume(p) {
  return {
          TAG: /* PResume */0,
          _0: p
        };
}

function sexp_to_json(l2j, param) {
  switch (param.TAG | 0) {
    case /* Nil */0 :
        return null;
    case /* Cons */1 :
        var match = param._0;
        return Js_dict.fromList({
                    hd: [
                      "location",
                      Curry._1(l2j, match[0])
                    ],
                    tl: {
                      hd: [
                        "h",
                        sexp_to_json(l2j, match[1])
                      ],
                      tl: {
                        hd: [
                          "t",
                          sexp_to_json(l2j, match[2])
                        ],
                        tl: /* [] */0
                      }
                    }
                  });
    case /* Integer */2 :
        var match$1 = param._0;
        return Js_dict.fromList({
                    hd: [
                      "integer",
                      match$1[1]
                    ],
                    tl: {
                      hd: [
                        "location",
                        Curry._1(l2j, match$1[0])
                      ],
                      tl: /* [] */0
                    }
                  });
    case /* QuotedString */3 :
        var match$2 = param._0;
        return Js_dict.fromList({
                    hd: [
                      "string",
                      match$2[2]
                    ],
                    tl: {
                      hd: [
                        "location",
                        Curry._1(l2j, match$2[0])
                      ],
                      tl: {
                        hd: [
                          "quote",
                          $$String.make(1, match$2[1])
                        ],
                        tl: /* [] */0
                      }
                    }
                  });
    case /* Atom */4 :
        var match$3 = param._0;
        return Js_dict.fromList({
                    hd: [
                      "atom",
                      match$3[1]
                    ],
                    tl: {
                      hd: [
                        "location",
                        Curry._1(l2j, match$3[0])
                      ],
                      tl: /* [] */0
                    }
                  });
    
  }
}

function isspace(param) {
  if (param > 13 || param < 8) {
    return param === 32;
  } else {
    return !(param === 12 || param === 11);
  }
}

function parse_sexp_step(ext, loc, pl) {
  if (typeof pl === "number") {
    return function (x) {
      if (x === 10) {
        return {
                TAG: /* PResume */0,
                _0: /* Empty */0
              };
      }
      if (x >= 42) {
        if (x === 59) {
          return {
                  TAG: /* PResume */0,
                  _0: {
                    TAG: /* CommentText */0,
                    _0: [
                      loc,
                      ""
                    ]
                  }
                };
        }
        
      } else if (x >= 34) {
        switch (x) {
          case 34 :
              return {
                      TAG: /* PResume */0,
                      _0: {
                        TAG: /* QuotedText */2,
                        _0: [
                          loc,
                          /* '"' */34,
                          ""
                        ]
                      }
                    };
          case 35 :
          case 36 :
          case 37 :
          case 38 :
              break;
          case 39 :
              return {
                      TAG: /* PResume */0,
                      _0: {
                        TAG: /* QuotedText */2,
                        _0: [
                          loc,
                          /* '\'' */39,
                          ""
                        ]
                      }
                    };
          case 40 :
              return {
                      TAG: /* PResume */0,
                      _0: {
                        TAG: /* OpenList */4,
                        _0: loc
                      }
                    };
          case 41 :
              return {
                      TAG: /* PError */2,
                      _0: [
                        loc,
                        "Too many close parens"
                      ]
                    };
          
        }
      }
      if (isspace(x)) {
        return {
                TAG: /* PResume */0,
                _0: /* Empty */0
              };
      } else {
        return {
                TAG: /* PResume */0,
                _0: {
                  TAG: /* Bareword */1,
                  _0: [
                    loc,
                    $$String.make(1, x)
                  ]
                }
              };
      }
    };
  }
  switch (pl.TAG | 0) {
    case /* CommentText */0 :
        var match = pl._0;
        var t = match[1];
        var pl$1 = match[0];
        return function (x) {
          if (x !== 10) {
            if (x !== 13) {
              return {
                      TAG: /* PResume */0,
                      _0: {
                        TAG: /* CommentText */0,
                        _0: [
                          Curry._2(ext, pl$1, loc),
                          t + $$String.make(1, x)
                        ]
                      }
                    };
            } else {
              return {
                      TAG: /* PResume */0,
                      _0: {
                        TAG: /* CommentText */0,
                        _0: [
                          pl$1,
                          t
                        ]
                      }
                    };
            }
          } else {
            return {
                    TAG: /* PResume */0,
                    _0: /* Empty */0
                  };
          }
        };
    case /* Bareword */1 :
        var match$1 = pl._0;
        var a = match$1[1];
        var pl$2 = match$1[0];
        return function (ch) {
          if (!isspace(ch)) {
            return {
                    TAG: /* PResume */0,
                    _0: {
                      TAG: /* Bareword */1,
                      _0: [
                        Curry._2(ext, pl$2, loc),
                        a + $$String.make(1, ch)
                      ]
                    }
                  };
          }
          var a$1 = make_atom(pl$2, a);
          return {
                  TAG: /* PEmit */1,
                  _0: [
                    a$1,
                    /* Empty */0
                  ]
                };
        };
    case /* QuotedText */2 :
        var match$2 = pl._0;
        var t$1 = match$2[2];
        var term = match$2[1];
        var pl$3 = match$2[0];
        return function (ch) {
          if (ch === 92) {
            return {
                    TAG: /* PResume */0,
                    _0: {
                      TAG: /* QuotedEscaped */3,
                      _0: [
                        pl$3,
                        term,
                        t$1
                      ]
                    }
                  };
          }
          if (ch !== term) {
            return {
                    TAG: /* PResume */0,
                    _0: {
                      TAG: /* QuotedText */2,
                      _0: [
                        pl$3,
                        term,
                        t$1 + $$String.make(1, ch)
                      ]
                    }
                  };
          }
          var a = {
            TAG: /* QuotedString */3,
            _0: [
              Curry._2(ext, pl$3, loc),
              term,
              t$1
            ]
          };
          return {
                  TAG: /* PEmit */1,
                  _0: [
                    a,
                    /* Empty */0
                  ]
                };
        };
    case /* QuotedEscaped */3 :
        var match$3 = pl._0;
        var t$2 = match$3[2];
        var term$1 = match$3[1];
        var pl$4 = match$3[0];
        return function (ch) {
          return {
                  TAG: /* PResume */0,
                  _0: {
                    TAG: /* QuotedText */2,
                    _0: [
                      pl$4,
                      term$1,
                      t$2 + $$String.make(1, ch)
                    ]
                  }
                };
        };
    case /* OpenList */4 :
        var pl$5 = pl._0;
        return function (x) {
          if (x !== 41) {
            if (x === 46) {
              return {
                      TAG: /* PError */2,
                      _0: [
                        loc,
                        "Dot can't appear directly after begin paren"
                      ]
                    };
            }
            var p = parse_sexp_step(ext, loc, /* Empty */0)(x);
            switch (p.TAG | 0) {
              case /* PResume */0 :
                  return {
                          TAG: /* PResume */0,
                          _0: {
                            TAG: /* ParsingList */5,
                            _0: [
                              Curry._2(ext, pl$5, loc),
                              p._0,
                              (function (r) {
                                  return r;
                                })
                            ]
                          }
                        };
              case /* PEmit */1 :
                  var match = p._0;
                  var o = match[0];
                  return {
                          TAG: /* PResume */0,
                          _0: {
                            TAG: /* ParsingList */5,
                            _0: [
                              Curry._2(ext, pl$5, loc),
                              match[1],
                              (function (param) {
                                  return make_cons(ext, o, param);
                                })
                            ]
                          }
                        };
              case /* PError */2 :
                  return {
                          TAG: /* PError */2,
                          _0: p._0
                        };
              
            }
          } else {
            var a = {
              TAG: /* Nil */0,
              _0: Curry._2(ext, pl$5, loc)
            };
            return {
                    TAG: /* PEmit */1,
                    _0: [
                      a,
                      /* Empty */0
                    ]
                  };
          }
        };
    case /* ParsingList */5 :
        var match$4 = pl._0;
        var list_content = match$4[2];
        var pp = match$4[1];
        var pl$6 = match$4[0];
        return function (ch) {
          if (ch !== 41) {
            if (ch === 46 && typeof pp === "number") {
              return {
                      TAG: /* PResume */0,
                      _0: {
                        TAG: /* TermList */6,
                        _0: [
                          Curry._2(ext, pl$6, loc),
                          /* Empty */0,
                          list_content
                        ]
                      }
                    };
            }
            
          } else {
            if (typeof pp === "number") {
              var a = Curry._1(list_content, {
                    TAG: /* Nil */0,
                    _0: loc
                  });
              return {
                      TAG: /* PEmit */1,
                      _0: [
                        a,
                        /* Empty */0
                      ]
                    };
            }
            if (pp.TAG === /* Bareword */1) {
              var match = pp._0;
              var parsed_atom = make_atom(match[0], match[1]);
              var finished_list = make_cons(ext, parsed_atom, {
                    TAG: /* Nil */0,
                    _0: loc
                  });
              var a$1 = Curry._1(list_content, finished_list);
              return {
                      TAG: /* PEmit */1,
                      _0: [
                        a$1,
                        /* Empty */0
                      ]
                    };
            }
            
          }
          var rp = parse_sexp_step(ext, loc, pp)(ch);
          switch (rp.TAG | 0) {
            case /* PResume */0 :
                return {
                        TAG: /* PResume */0,
                        _0: {
                          TAG: /* ParsingList */5,
                          _0: [
                            Curry._2(ext, pl$6, loc),
                            rp._0,
                            list_content
                          ]
                        }
                      };
            case /* PEmit */1 :
                var match$1 = rp._0;
                var o = match$1[0];
                return {
                        TAG: /* PResume */0,
                        _0: {
                          TAG: /* ParsingList */5,
                          _0: [
                            Curry._2(ext, pl$6, loc),
                            match$1[1],
                            (function (rest) {
                                return Curry._1(list_content, make_cons(ext, o, rest));
                              })
                          ]
                        }
                      };
            case /* PError */2 :
                return {
                        TAG: /* PError */2,
                        _0: rp._0
                      };
            
          }
        };
    case /* TermList */6 :
        var match$5 = pl._0;
        var list_content$1 = match$5[2];
        var pp$1 = match$5[1];
        var pl$7 = match$5[0];
        return function (ch) {
          if (ch !== 41) {
            if (ch === 46 && typeof pp$1 === "number") {
              return {
                      TAG: /* PError */2,
                      _0: [
                        loc,
                        "Multiple dots in list notation are illegal"
                      ]
                    };
            }
            
          } else {
            if (typeof pp$1 === "number") {
              var a = Curry._1(list_content$1, {
                    TAG: /* Nil */0,
                    _0: loc
                  });
              return {
                      TAG: /* PEmit */1,
                      _0: [
                        a,
                        /* Empty */0
                      ]
                    };
            }
            if (pp$1.TAG === /* Bareword */1) {
              var match = pp$1._0;
              var parsed_atom = make_atom(match[0], match[1]);
              var a$1 = Curry._1(list_content$1, parsed_atom);
              return {
                      TAG: /* PEmit */1,
                      _0: [
                        a$1,
                        /* Empty */0
                      ]
                    };
            }
            
          }
          var p = parse_sexp_step(ext, loc, pp$1)(ch);
          switch (p.TAG | 0) {
            case /* PResume */0 :
                return {
                        TAG: /* PResume */0,
                        _0: {
                          TAG: /* TermList */6,
                          _0: [
                            Curry._2(ext, pl$7, loc),
                            p._0,
                            list_content$1
                          ]
                        }
                      };
            case /* PEmit */1 :
                var match$1 = p._0;
                var o = match$1[0];
                return {
                        TAG: /* PResume */0,
                        _0: {
                          TAG: /* ParsingList */5,
                          _0: [
                            Curry._2(ext, pl$7, loc),
                            match$1[1],
                            (function (param) {
                                return Curry._1(list_content$1, o);
                              })
                          ]
                        }
                      };
            case /* PError */2 :
                return {
                        TAG: /* PError */2,
                        _0: p._0
                      };
            
          }
        };
    
  }
}

function parse_sexp_inner(ext, _start, advance, _p, _n, s) {
  while(true) {
    var n = _n;
    var p = _p;
    var start = _start;
    if (n >= s.length) {
      if (typeof p === "number") {
        return {
                TAG: /* Success */0,
                _0: /* [] */0
              };
      }
      switch (p.TAG | 0) {
        case /* CommentText */0 :
            return {
                    TAG: /* Success */0,
                    _0: /* [] */0
                  };
        case /* Bareword */1 :
            var match = p._0;
            return {
                    TAG: /* Success */0,
                    _0: {
                      hd: make_atom(match[0], match[1]),
                      tl: /* [] */0
                    }
                  };
        case /* QuotedText */2 :
            return {
                    TAG: /* Failure */1,
                    _0: [
                      p._0[0],
                      "unterminated quoted string"
                    ]
                  };
        case /* QuotedEscaped */3 :
            return {
                    TAG: /* Failure */1,
                    _0: [
                      p._0[0],
                      "unterminated quoted string with escape"
                    ]
                  };
        case /* OpenList */4 :
            return {
                    TAG: /* Failure */1,
                    _0: [
                      p._0,
                      "Unterminated list (empty)"
                    ]
                  };
        case /* ParsingList */5 :
            return {
                    TAG: /* Failure */1,
                    _0: [
                      p._0[0],
                      "Unterminated mid list"
                    ]
                  };
        case /* TermList */6 :
            return {
                    TAG: /* Failure */1,
                    _0: [
                      p._0[0],
                      "Unterminated tail list"
                    ]
                  };
        
      }
    } else {
      var this_char = Caml_string.get(s, n);
      var next_location = Curry._2(advance, start, this_char);
      var np = parse_sexp_step(ext, start, p)(this_char);
      switch (np.TAG | 0) {
        case /* PResume */0 :
            _n = n + 1 | 0;
            _p = np._0;
            _start = next_location;
            continue ;
        case /* PEmit */1 :
            var match$1 = np._0;
            var f = parse_sexp_inner(ext, next_location, advance, match$1[1], n + 1 | 0, s);
            if (f.TAG === /* Success */0) {
              return {
                      TAG: /* Success */0,
                      _0: {
                        hd: match$1[0],
                        tl: f._0
                      }
                    };
            } else {
              return {
                      TAG: /* Failure */1,
                      _0: f._0
                    };
            }
        case /* PError */2 :
            var match$2 = np._0;
            return {
                    TAG: /* Failure */1,
                    _0: [
                      match$2[0],
                      match$2[1]
                    ]
                  };
        
      }
    }
  };
}

function parse_sexp(ext, start, advance) {
  return function (param) {
    return parse_sexp_inner(ext, start, advance, /* Empty */0, 0, param);
  };
}

function escape_quote(q, s) {
  var basic_escape = List.init(s.length, (function (i) {
          var ch = Caml_string.get(s, i);
          if (ch === q) {
            return "\\" + $$String.make(1, q);
          } else {
            return $$String.make(1, ch);
          }
        }));
  return $$String.concat("", basic_escape);
}

function to_string(param) {
  switch (param.TAG | 0) {
    case /* Nil */0 :
        return "()";
    case /* Cons */1 :
        var match = param._0;
        return "(" + (list_no_parens([
                      match[1],
                      match[2]
                    ]) + ")");
    case /* QuotedString */3 :
        var match$1 = param._0;
        return "\"" + (escape_quote(match$1[1], match$1[2]) + "\"");
    case /* Integer */2 :
    case /* Atom */4 :
        return param._0[1];
    
  }
}

function list_no_parens(param) {
  var b = param[1];
  var a = param[0];
  switch (b.TAG | 0) {
    case /* Nil */0 :
        return to_string(a);
    case /* Cons */1 :
        var match = b._0;
        return to_string(a) + (" " + list_no_parens([
                      match[1],
                      match[2]
                    ]));
    default:
      return to_string(a) + (" . " + to_string(b));
  }
}

function is_zero_integer(v) {
  var other_symbol = false;
  var slen = v.length;
  for(var i = 0; i < slen; ++i){
    var match = Caml_string.get(v, i);
    if (match !== 48 && match !== 120) {
      other_symbol = true;
    }
    
  }
  return !other_symbol;
}

function nilp(param) {
  switch (param.TAG | 0) {
    case /* Nil */0 :
        return true;
    case /* Integer */2 :
        return is_zero_integer(param._0[1]);
    case /* QuotedString */3 :
        if (param._0[2] === "") {
          return true;
        } else {
          return false;
        }
    case /* Cons */1 :
    case /* Atom */4 :
        return false;
    
  }
}

function listp(param) {
  switch (param.TAG | 0) {
    case /* Nil */0 :
    case /* Cons */1 :
        return true;
    default:
      return false;
  }
}

function cons_fst(param) {
  if (param.TAG === /* Cons */1) {
    return param._0[1];
  } else {
    return {
            TAG: /* Nil */0,
            _0: Srcloc.start
          };
  }
}

function cons_snd(param) {
  if (param.TAG === /* Cons */1) {
    return param._0[2];
  } else {
    return {
            TAG: /* Nil */0,
            _0: Srcloc.start
          };
  }
}

function encode_hex_digit_list(bi) {
  var encoded = BigInteger.toString(bi, 16, undefined);
  var enclen = encoded.length;
  var padded = enclen % 2 === 0 ? encoded : "0" + encoded;
  var elen = BigInteger$1((padded.length >> 1));
  var len40 = BigInteger$1(64);
  var len2000 = BigInteger$1(8192);
  var len1000000 = BigInteger$1(16777216);
  var len80000000 = BigInteger$1(-2147483648);
  var lenOr = elen.lesser(len40) ? BigInteger$1(128) : (
      elen.lesser(len2000) ? BigInteger$1(49152) : (
          elen.lesser(len1000000) ? BigInteger$1(-536870912) : (
              elen.lesser(len80000000) ? BigInteger$1("0xf0000000", 16) : BigInteger$1("0xf80000000000", 16)
            )
        )
    );
  return BigInteger.toString(BigInteger.plus(elen, {
                  NAME: "BigInt",
                  VAL: lenOr
                }), 16, undefined) + padded;
}

function encode_integer_value(v) {
  var bi = BigInteger$1(v, 16);
  if (bi.greater(127)) {
    return encode_hex_digit_list(bi);
  } else {
    return Curry._1(Printf.sprintf(/* Format */{
                    _0: {
                      TAG: /* Int */4,
                      _0: /* Int_x */6,
                      _1: {
                        TAG: /* Lit_padding */0,
                        _0: /* Zeros */2,
                        _1: 2
                      },
                      _2: /* No_precision */0,
                      _3: /* End_of_format */0
                    },
                    _1: "%02x"
                  }), bi.toJSNumber());
  }
}

function encode_string_to_bigint(v) {
  var enc_array = $$Array.init(v.length, (function (i) {
          return Curry._1(Printf.sprintf(/* Format */{
                          _0: {
                            TAG: /* Int */4,
                            _0: /* Int_x */6,
                            _1: {
                              TAG: /* Lit_padding */0,
                              _0: /* Zeros */2,
                              _1: 2
                            },
                            _2: /* No_precision */0,
                            _3: /* End_of_format */0
                          },
                          _1: "%02x"
                        }), Caml_string.get(v, i));
        }));
  return $$String.concat("", $$Array.to_list(enc_array));
}

function encode_int_to_bigint(v) {
  return BigInteger.toString(BigInteger$1(v), 16, undefined);
}

function encode(param) {
  switch (param.TAG | 0) {
    case /* Nil */0 :
        return "80";
    case /* Cons */1 :
        var match = param._0;
        return "ff" + (encode(match[1]) + encode(match[2]));
    case /* Integer */2 :
        return encode_integer_value(param._0[1]);
    case /* QuotedString */3 :
        return encode_integer_value(encode_string_to_bigint(param._0[2]));
    case /* Atom */4 :
        return encode_integer_value(encode_string_to_bigint(param._0[1]));
    
  }
}

function intval(v) {
  return BigInteger$1(v).toJSNumber();
}

function sexp_to_bigint(param) {
  switch (param.TAG | 0) {
    case /* Nil */0 :
        return Caml_option.some(BigInteger$1(0));
    case /* Cons */1 :
        return ;
    case /* Integer */2 :
        return Caml_option.some(BigInteger$1(param._0[1]));
    case /* QuotedString */3 :
        return Caml_option.some(BigInteger$1(({
                          NAME: "String",
                          VAL: encode_string_to_bigint(param._0[2])
                        }).VAL, 16));
    case /* Atom */4 :
        return Caml_option.some(BigInteger$1(({
                          NAME: "String",
                          VAL: encode_string_to_bigint(param._0[1])
                        }).VAL, 16));
    
  }
}

function equal(_a, _b) {
  while(true) {
    var b = _b;
    var a = _a;
    if (nilp(a) && nilp(b)) {
      return true;
    }
    if (nilp(a) || nilp(b)) {
      return false;
    }
    switch (a.TAG | 0) {
      case /* Cons */1 :
          var match = a._0;
          if (b.TAG !== /* Cons */1) {
            return false;
          }
          var match$1 = b._0;
          if (!equal(match[1], match$1[1])) {
            return false;
          }
          _b = match$1[2];
          _a = match[2];
          continue ;
      case /* Integer */2 :
          switch (b.TAG | 0) {
            case /* Cons */1 :
                break;
            case /* Integer */2 :
                return a._0[1] === b._0[1];
            default:
              return encode(a) === encode(b);
          }
          break;
      default:
        
    }
    if (b.TAG === /* Cons */1) {
      return false;
    } else {
      return encode(a) === encode(b);
    }
  };
}

exports.location_of = location_of;
exports.make_cons = make_cons;
exports.matches_integral = matches_integral;
exports.normalize_int = normalize_int;
exports.make_atom = make_atom;
exports.emit = emit;
exports.error = error;
exports.resume = resume;
exports.sexp_to_json = sexp_to_json;
exports.isspace = isspace;
exports.parse_sexp_step = parse_sexp_step;
exports.parse_sexp_inner = parse_sexp_inner;
exports.parse_sexp = parse_sexp;
exports.escape_quote = escape_quote;
exports.to_string = to_string;
exports.list_no_parens = list_no_parens;
exports.is_zero_integer = is_zero_integer;
exports.nilp = nilp;
exports.listp = listp;
exports.cons_fst = cons_fst;
exports.cons_snd = cons_snd;
exports.encode_hex_digit_list = encode_hex_digit_list;
exports.encode_integer_value = encode_integer_value;
exports.encode_string_to_bigint = encode_string_to_bigint;
exports.encode_int_to_bigint = encode_int_to_bigint;
exports.encode = encode;
exports.intval = intval;
exports.sexp_to_bigint = sexp_to_bigint;
exports.equal = equal;
/* BigInteger Not a pure module */
