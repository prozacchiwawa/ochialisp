// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Sexp = require("./sexp.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Srcloc = require("./srcloc.js");
var Comptypes = require("./comptypes.js");

function process_include(opts, name) {
  return Comptypes.compBind((function (param) {
                var parse_result = Sexp.parse_sexp(Srcloc.combineSrcLocation, Srcloc.start(opts.filename), Srcloc.advance)(param[1]);
                if (parse_result.TAG === /* Success */0) {
                  return {
                          TAG: /* CompileOk */0,
                          _0: parse_result._0
                        };
                }
                var match = parse_result._0;
                return {
                        TAG: /* CompileError */1,
                        _0: match[0],
                        _1: match[1]
                      };
              }), Curry._3(opts.readNewFile, opts, opts.filename, name));
}

function process_pp_form(opts, any) {
  if (any.TAG !== /* Cons */1) {
    return {
            TAG: /* CompileOk */0,
            _0: {
              hd: any,
              tl: /* [] */0
            }
          };
  }
  var match = any._0;
  var match$1 = match[1];
  if (match$1.TAG !== /* Atom */4) {
    return {
            TAG: /* CompileOk */0,
            _0: {
              hd: any,
              tl: /* [] */0
            }
          };
  }
  if (match$1._0[1] !== "include") {
    return {
            TAG: /* CompileOk */0,
            _0: {
              hd: any,
              tl: /* [] */0
            }
          };
  }
  var any$1 = match[2];
  if (any$1.TAG === /* Cons */1) {
    var match$2 = any$1._0;
    var match$3 = match$2[1];
    switch (match$3.TAG | 0) {
      case /* QuotedString */3 :
          if (match$2[2].TAG === /* Nil */0) {
            return process_include(opts, match$3._0[2]);
          }
          break;
      case /* Atom */4 :
          if (match$2[2].TAG === /* Nil */0) {
            return process_include(opts, match$3._0[1]);
          }
          break;
      default:
        
    }
  }
  return {
          TAG: /* CompileError */1,
          _0: match[0],
          _1: Curry._1(Printf.sprintf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "bad tail ",
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: " in include",
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "bad tail %s in include"
                  }), Sexp.to_string(any$1))
        };
}

function preprocess_(opts, any) {
  if (any.TAG !== /* Cons */1) {
    return {
            TAG: /* CompileOk */0,
            _0: {
              hd: any,
              tl: /* [] */0
            }
          };
  }
  var match = any._0;
  var _nl = match[2];
  var head = match[1];
  if (_nl.TAG === /* Nil */0) {
    return process_pp_form(opts, head);
  } else {
    return Comptypes.compBind((function (lst) {
                  return Comptypes.compMap((function (rs) {
                                return List.concat({
                                            hd: lst,
                                            tl: {
                                              hd: rs,
                                              tl: /* [] */0
                                            }
                                          });
                              }), preprocess_(opts, _nl));
                }), process_pp_form(opts, head));
  }
}

function inject_std_macros(body) {
  var l = Sexp.location_of(body);
  return {
          TAG: /* Cons */1,
          _0: [
            l,
            {
              TAG: /* Cons */1,
              _0: [
                l,
                {
                  TAG: /* Atom */4,
                  _0: [
                    l,
                    "include"
                  ]
                },
                {
                  TAG: /* Cons */1,
                  _0: [
                    l,
                    {
                      TAG: /* QuotedString */3,
                      _0: [
                        l,
                        /* '"' */34,
                        "*macros*"
                      ]
                    },
                    {
                      TAG: /* Nil */0,
                      _0: l
                    }
                  ]
                }
              ]
            },
            body
          ]
        };
}

function preprocess(opts, cmod) {
  var tocompile = opts.stdenv ? inject_std_macros(cmod) : cmod;
  return preprocess_(opts, tocompile);
}

exports.process_include = process_include;
exports.process_pp_form = process_pp_form;
exports.preprocess_ = preprocess_;
exports.inject_std_macros = inject_std_macros;
exports.preprocess = preprocess;
/* Sexp Not a pure module */
