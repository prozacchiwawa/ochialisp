// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Sexp = require("./sexp.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Rename = require("./rename.js");
var Srcloc = require("./srcloc.js");
var Comptypes = require("./comptypes.js");
var Preprocessor = require("./preprocessor.js");

function collect_used_names_sexp(param) {
  switch (param.TAG | 0) {
    case /* Cons */1 :
        var match = param._0;
        return List.concat({
                    hd: collect_used_names_sexp(match[1]),
                    tl: {
                      hd: collect_used_names_sexp(match[2]),
                      tl: /* [] */0
                    }
                  });
    case /* Atom */4 :
        return {
                hd: param._0[1],
                tl: /* [] */0
              };
    default:
      return /* [] */0;
  }
}

function collect_used_names_binding(param) {
  return collect_used_names_bodyForm(param._0[2]);
}

function collect_used_names_bodyForm(_e) {
  switch (_e.TAG | 0) {
    case /* Let */0 :
        var match = _e._0;
        return List.concat({
                    hd: List.concat(List.map(collect_used_names_binding, match[1])),
                    tl: {
                      hd: collect_used_names_bodyForm(match[2]),
                      tl: /* [] */0
                    }
                  });
    case /* Quoted */1 :
        var _e$1 = _e._0;
        if (_e$1.TAG === /* Atom */4) {
          return {
                  hd: _e$1._0[1],
                  tl: /* [] */0
                };
        } else {
          return /* [] */0;
        }
    case /* Value */2 :
        var match$1 = _e._0;
        if (match$1.TAG === /* Atom */4) {
          return {
                  hd: match$1._0[1],
                  tl: /* [] */0
                };
        } else {
          return /* [] */0;
        }
    case /* Call */3 :
        return List.concat(List.map(collect_used_names_bodyForm, _e._0[1]));
    
  }
}

function collect_used_names_helperForm(param) {
  switch (param.TAG | 0) {
    case /* Defconstant */0 :
        return collect_used_names_bodyForm(param._0[2]);
    case /* Defmacro */1 :
        return collect_used_names_compileForm(param._0[3]);
    case /* Defun */2 :
        return collect_used_names_bodyForm(param._0[4]);
    
  }
}

function collect_used_names_compileForm(param) {
  var match = param._0;
  return List.concat({
              hd: List.concat(List.map(collect_used_names_helperForm, match[2])),
              tl: {
                hd: collect_used_names_bodyForm(match[3]),
                tl: /* [] */0
              }
            });
}

function calculate_live_helpers(opts, _last_names, _names, helper_map) {
  while(true) {
    var names = _names;
    var last_names = _last_names;
    if (Curry._1(Comptypes.StringSet.cardinal, last_names) === Curry._1(Comptypes.StringSet.cardinal, names)) {
      return names;
    }
    var new_names = Curry._2(Comptypes.StringSet.diff, names, last_names);
    var needed_helpers = List.fold_left((function (found, name) {
            try {
              var new_helper = Curry._2(Comptypes.StringMap.find, name, helper_map);
              var even_newer_names = collect_used_names_helperForm(new_helper);
              return Curry._2(Comptypes.StringSet.union, found, Curry._1(Comptypes.StringSet.of_list, even_newer_names));
            }
            catch (exn){
              return found;
            }
          }), names, Curry._1(Comptypes.StringSet.elements, new_names));
    _names = needed_helpers;
    _last_names = names;
    continue ;
  };
}

function qq_to_expression(any) {
  if (any.TAG !== /* Cons */1) {
    return {
            TAG: /* CompileOk */0,
            _0: {
              TAG: /* Quoted */1,
              _0: any
            }
          };
  }
  var match = any._0;
  var f = match[1];
  var l = match[0];
  if (f.TAG === /* Atom */4) {
    var match$1 = f._0;
    var lq = match$1[0];
    switch (match$1[1]) {
      case "q" :
          return {
                  TAG: /* CompileOk */0,
                  _0: {
                    TAG: /* Quoted */1,
                    _0: {
                      TAG: /* Cons */1,
                      _0: [
                        l,
                        {
                          TAG: /* Atom */4,
                          _0: [
                            lq,
                            "q"
                          ]
                        },
                        match[2]
                      ]
                    }
                  }
                };
      case "quote" :
          var match$2 = match[2];
          if (match$2.TAG === /* Cons */1) {
            var match$3 = match$2._0;
            var ln = match$3[2];
            if (ln.TAG === /* Nil */0) {
              return {
                      TAG: /* CompileOk */0,
                      _0: {
                        TAG: /* Quoted */1,
                        _0: {
                          TAG: /* Cons */1,
                          _0: [
                            l,
                            {
                              TAG: /* Atom */4,
                              _0: [
                                lq,
                                "quote"
                              ]
                            },
                            {
                              TAG: /* Cons */1,
                              _0: [
                                match$3[0],
                                match$3[1],
                                {
                                  TAG: /* Nil */0,
                                  _0: ln._0
                                }
                              ]
                            }
                          ]
                        }
                      }
                    };
            }
            
          }
          break;
      case "unquote" :
          var match$4 = match[2];
          if (match$4.TAG === /* Cons */1) {
            var match$5 = match$4._0;
            if (match$5[2].TAG === /* Nil */0) {
              return compile_bodyform(match$5[1]);
            }
            
          }
          break;
      default:
        
    }
  }
  return qq_to_expression_list({
              TAG: /* Cons */1,
              _0: [
                l,
                f,
                match[2]
              ]
            });
}

function qq_to_expression_list(l) {
  switch (l.TAG | 0) {
    case /* Nil */0 :
        return {
                TAG: /* CompileOk */0,
                _0: {
                  TAG: /* Quoted */1,
                  _0: {
                    TAG: /* Nil */0,
                    _0: l._0
                  }
                }
              };
    case /* Cons */1 :
        var match = l._0;
        var r = match[2];
        var l$1 = match[0];
        return Comptypes.compBind((function (f) {
                      return Comptypes.compMap((function (r) {
                                    return {
                                            TAG: /* Call */3,
                                            _0: [
                                              l$1,
                                              {
                                                hd: {
                                                  TAG: /* Value */2,
                                                  _0: {
                                                    TAG: /* Atom */4,
                                                    _0: [
                                                      l$1,
                                                      "c"
                                                    ]
                                                  }
                                                },
                                                tl: {
                                                  hd: f,
                                                  tl: {
                                                    hd: r,
                                                    tl: /* [] */0
                                                  }
                                                }
                                              }
                                            ]
                                          };
                                  }), qq_to_expression_list(r));
                    }), qq_to_expression(match[1]));
    default:
      return {
              TAG: /* CompileError */1,
              _0: Sexp.location_of(l),
              _1: "Bad list tail " + Sexp.to_string(l)
            };
  }
}

function args_to_expression_list(_l) {
  switch (_l.TAG | 0) {
    case /* Nil */0 :
        return {
                TAG: /* CompileOk */0,
                _0: /* [] */0
              };
    case /* Cons */1 :
        var match = _l._0;
        var first = match[1];
        return Comptypes.compBind((function (args) {
                      return Comptypes.compMap((function (f) {
                                    return {
                                            hd: f,
                                            tl: args
                                          };
                                  }), compile_bodyform(first));
                    }), args_to_expression_list(match[2]));
    default:
      return {
              TAG: /* CompileError */1,
              _0: Sexp.location_of(_l),
              _1: "Bad list tail " + Sexp.to_string(_l)
            };
  }
}

function compile_bodyform(any) {
  if (any.TAG !== /* Cons */1) {
    return {
            TAG: /* CompileOk */0,
            _0: {
              TAG: /* Value */2,
              _0: any
            }
          };
  }
  var match = any._0;
  var head = match[1];
  var l = match[0];
  switch (head.TAG | 0) {
    case /* Integer */2 :
        if (head._0[1] === "1") {
          return {
                  TAG: /* CompileOk */0,
                  _0: {
                    TAG: /* Quoted */1,
                    _0: match[2]
                  }
                };
        }
        break;
    case /* Atom */4 :
        switch (head._0[1]) {
          case "let" :
              var match$1 = match[2];
              if (match$1.TAG !== /* Cons */1) {
                return {
                        TAG: /* CompileError */1,
                        _0: l,
                        _1: "bad let form"
                      };
              }
              var match$2 = match$1._0[2];
              if (match$2.TAG === /* Cons */1 && match$2._0[2].TAG === /* Nil */0) {
                return {
                        TAG: /* CompileError */1,
                        _0: l,
                        _1: "can't yet compile let"
                      };
              } else {
                return {
                        TAG: /* CompileError */1,
                        _0: l,
                        _1: "bad let form"
                      };
              }
          case "q" :
              return {
                      TAG: /* CompileOk */0,
                      _0: {
                        TAG: /* Quoted */1,
                        _0: match[2]
                      }
                    };
          case "qq" :
              var match$3 = match[2];
              if (match$3.TAG === /* Cons */1) {
                var match$4 = match$3._0;
                if (match$4[2].TAG === /* Nil */0) {
                  return qq_to_expression(match$4[1]);
                }
                
              }
              break;
          case "quote" :
              var match$5 = match[2];
              if (match$5.TAG === /* Cons */1) {
                var match$6 = match$5._0;
                if (match$6[2].TAG === /* Nil */0) {
                  return {
                          TAG: /* CompileOk */0,
                          _0: {
                            TAG: /* Quoted */1,
                            _0: match$6[1]
                          }
                        };
                }
                
              }
              break;
          default:
            
        }
        break;
    default:
      
  }
  return Comptypes.compBind((function (args) {
                return Comptypes.compMap((function (func) {
                              return {
                                      TAG: /* Call */3,
                                      _0: [
                                        l,
                                        {
                                          hd: func,
                                          tl: args
                                        }
                                      ]
                                    };
                            }), compile_bodyform(head));
              }), args_to_expression_list(match[2]));
}

function compile_defconstant(l, name, body) {
  return Comptypes.compMap((function (bf) {
                return {
                        TAG: /* Defconstant */0,
                        _0: [
                          l,
                          name,
                          bf
                        ]
                      };
              }), compile_bodyform(body));
}

function compile_defun(l, inline, name, args, body) {
  return Comptypes.compMap((function (bf) {
                return {
                        TAG: /* Defun */2,
                        _0: [
                          l,
                          name,
                          inline,
                          args,
                          bf
                        ]
                      };
              }), compile_bodyform(body));
}

function compile_defmacro(opts, l, name, args, body) {
  var program = {
    TAG: /* Cons */1,
    _0: [
      l,
      {
        TAG: /* Atom */4,
        _0: [
          l,
          "mod"
        ]
      },
      {
        TAG: /* Cons */1,
        _0: [
          l,
          args,
          body
        ]
      }
    ]
  };
  var opts_includeDirs = opts.includeDirs;
  var opts_filename = opts.filename;
  var opts_readNewFile = opts.readNewFile;
  var opts_compiler = opts.compiler;
  var opts_compileProgram = opts.compileProgram;
  var opts_inDefun = opts.inDefun;
  var opts_assemble = opts.assemble;
  var opts_startEnv = opts.startEnv;
  var opts$1 = {
    includeDirs: opts_includeDirs,
    filename: opts_filename,
    readNewFile: opts_readNewFile,
    compiler: opts_compiler,
    compileProgram: opts_compileProgram,
    inDefun: opts_inDefun,
    assemble: opts_assemble,
    stdenv: false,
    startEnv: opts_startEnv
  };
  return Comptypes.compMap((function (p) {
                return {
                        TAG: /* Defmacro */1,
                        _0: [
                          l,
                          name,
                          args,
                          p
                        ]
                      };
              }), frontend(opts$1, {
                  hd: program,
                  tl: /* [] */0
                }));
}

function compile_helperform(opts, param) {
  if (param.TAG !== /* Cons */1) {
    return {
            TAG: /* CompileOk */0,
            _0: undefined
          };
  }
  var match = param._0;
  var match$1 = match[1];
  if (match$1.TAG !== /* Atom */4) {
    return {
            TAG: /* CompileOk */0,
            _0: undefined
          };
  }
  var l = match[0];
  switch (match$1._0[1]) {
    case "defconstant" :
        var match$2 = match[2];
        if (match$2.TAG !== /* Cons */1) {
          return {
                  TAG: /* CompileOk */0,
                  _0: undefined
                };
        }
        var match$3 = match$2._0;
        var match$4 = match$3[1];
        if (match$4.TAG !== /* Atom */4) {
          return {
                  TAG: /* CompileOk */0,
                  _0: undefined
                };
        }
        var match$5 = match$3[2];
        if (match$5.TAG !== /* Cons */1) {
          return {
                  TAG: /* CompileOk */0,
                  _0: undefined
                };
        }
        var match$6 = match$5._0;
        if (match$6[2].TAG === /* Nil */0) {
          return Comptypes.compMap((function (a) {
                        return a;
                      }), compile_defconstant(l, match$4._0[1], match$6[1]));
        } else {
          return {
                  TAG: /* CompileOk */0,
                  _0: undefined
                };
        }
    case "defmacro" :
        var match$7 = match[2];
        if (match$7.TAG !== /* Cons */1) {
          return {
                  TAG: /* CompileOk */0,
                  _0: undefined
                };
        }
        var match$8 = match$7._0;
        var match$9 = match$8[1];
        if (match$9.TAG !== /* Atom */4) {
          return {
                  TAG: /* CompileOk */0,
                  _0: undefined
                };
        }
        var match$10 = match$8[2];
        if (match$10.TAG !== /* Cons */1) {
          return {
                  TAG: /* CompileOk */0,
                  _0: undefined
                };
        }
        var match$11 = match$10._0;
        return Comptypes.compMap((function (a) {
                      return a;
                    }), compile_defmacro(opts, l, match$9._0[1], match$11[1], match$11[2]));
    case "defun" :
        var match$12 = match[2];
        if (match$12.TAG !== /* Cons */1) {
          return {
                  TAG: /* CompileOk */0,
                  _0: undefined
                };
        }
        var match$13 = match$12._0;
        var match$14 = match$13[1];
        if (match$14.TAG !== /* Atom */4) {
          return {
                  TAG: /* CompileOk */0,
                  _0: undefined
                };
        }
        var match$15 = match$13[2];
        if (match$15.TAG !== /* Cons */1) {
          return {
                  TAG: /* CompileOk */0,
                  _0: undefined
                };
        }
        var match$16 = match$15._0;
        var match$17 = match$16[2];
        if (match$17.TAG !== /* Cons */1) {
          return {
                  TAG: /* CompileOk */0,
                  _0: undefined
                };
        }
        var match$18 = match$17._0;
        if (match$18[2].TAG === /* Nil */0) {
          return Comptypes.compMap((function (a) {
                        return a;
                      }), compile_defun(l, false, match$14._0[1], match$16[1], match$18[1]));
        } else {
          return {
                  TAG: /* CompileOk */0,
                  _0: undefined
                };
        }
    case "defun-inline" :
        var match$19 = match[2];
        if (match$19.TAG !== /* Cons */1) {
          return {
                  TAG: /* CompileOk */0,
                  _0: undefined
                };
        }
        var match$20 = match$19._0;
        var match$21 = match$20[1];
        if (match$21.TAG !== /* Atom */4) {
          return {
                  TAG: /* CompileOk */0,
                  _0: undefined
                };
        }
        var match$22 = match$20[2];
        if (match$22.TAG !== /* Cons */1) {
          return {
                  TAG: /* CompileOk */0,
                  _0: undefined
                };
        }
        var match$23 = match$22._0;
        var match$24 = match$23[2];
        if (match$24.TAG !== /* Cons */1) {
          return {
                  TAG: /* CompileOk */0,
                  _0: undefined
                };
        }
        var match$25 = match$24._0;
        if (match$25[2].TAG === /* Nil */0) {
          return Comptypes.compMap((function (a) {
                        return a;
                      }), compile_defun(l, true, match$21._0[1], match$23[1], match$25[1]));
        } else {
          return {
                  TAG: /* CompileOk */0,
                  _0: undefined
                };
        }
    default:
      return {
              TAG: /* CompileOk */0,
              _0: undefined
            };
  }
}

function compile_mod_(mc, opts, args, l) {
  switch (l.TAG | 0) {
    case /* Nil */0 :
        return {
                TAG: /* CompileError */1,
                _0: l._0,
                _1: "no expression at end of mod"
              };
    case /* Cons */1 :
        var match = l._0;
        var rest = match[2];
        var body = match[1];
        var l$1 = match[0];
        if (rest.TAG !== /* Nil */0) {
          return Comptypes.compBind((function (ma) {
                        return compile_mod_(ma, opts, args, rest);
                      }), Comptypes.compBind((function (form) {
                            if (form === undefined) {
                              return {
                                      TAG: /* CompileError */1,
                                      _0: l$1,
                                      _1: "only the last form can be an exprssion in mod"
                                    };
                            }
                            if (mc.TAG !== /* ModAccum */0) {
                              return {
                                      TAG: /* CompileError */1,
                                      _0: l$1,
                                      _1: "too many expressions"
                                    };
                            }
                            var match = mc._0;
                            var helpers = match[1];
                            return {
                                    TAG: /* CompileOk */0,
                                    _0: {
                                      TAG: /* ModAccum */0,
                                      _0: [
                                        match[0],
                                        (function (r) {
                                            return {
                                                    hd: form,
                                                    tl: Curry._1(helpers, r)
                                                  };
                                          })
                                      ]
                                    }
                                  };
                          }), compile_helperform(opts, body)));
        }
        if (mc.TAG !== /* ModAccum */0) {
          return {
                  TAG: /* CompileError */1,
                  _0: l$1,
                  _1: "too many expressions"
                };
        }
        var match$1 = mc._0;
        var helpers = match$1[1];
        var l$2 = match$1[0];
        return Comptypes.compMap((function (bf) {
                      return {
                              TAG: /* ModFinal */1,
                              _0: /* Mod */{
                                _0: [
                                  l$2,
                                  args,
                                  Curry._1(helpers, /* [] */0),
                                  bf
                                ]
                              }
                            };
                    }), compile_bodyform(body));
    default:
      return {
              TAG: /* CompileError */1,
              _0: Sexp.location_of(l),
              _1: Curry._1(Printf.sprintf(/* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "inappropriate sexp ",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: /* End_of_format */0
                          }
                        },
                        _1: "inappropriate sexp %s"
                      }), Sexp.to_string(l))
            };
  }
}

function frontend_start(opts, _pre_forms) {
  while(true) {
    var pre_forms = _pre_forms;
    if (!pre_forms) {
      return {
              TAG: /* CompileError */1,
              _0: Srcloc.start(opts.filename),
              _1: "empty source file not allowed"
            };
    }
    var hd = pre_forms.hd;
    if (hd.TAG === /* Cons */1) {
      var match = hd._0;
      var match$1 = match[1];
      if (match$1.TAG === /* Atom */4) {
        var l = match[0];
        if (match$1._0[1] === "mod") {
          var match$2 = match[2];
          if (match$2.TAG !== /* Cons */1) {
            return {
                    TAG: /* CompileError */1,
                    _0: l,
                    _1: "one toplevel mod form allowed"
                  };
          }
          if (pre_forms.tl) {
            return {
                    TAG: /* CompileError */1,
                    _0: l,
                    _1: "one toplevel mod form allowed"
                  };
          }
          var match$3 = match$2._0;
          var args = match$3[1];
          return Comptypes.compBind((function(l,args){
                    return function (ls) {
                      return compile_mod_({
                                  TAG: /* ModAccum */0,
                                  _0: [
                                    l,
                                    Comptypes.identity
                                  ]
                                }, opts, args, Comptypes.list_to_cons(l, Sexp.location_of)(ls));
                    }
                    }(l,args)), Preprocessor.preprocess(opts, match$3[2]));
        }
        
      }
      
    }
    var loc = Sexp.location_of(hd);
    _pre_forms = {
      hd: {
        TAG: /* Cons */1,
        _0: [
          loc,
          {
            TAG: /* Atom */4,
            _0: [
              loc,
              "mod"
            ]
          },
          {
            TAG: /* Cons */1,
            _0: [
              loc,
              {
                TAG: /* Nil */0,
                _0: loc
              },
              Comptypes.list_to_cons(loc, Sexp.location_of)(pre_forms)
            ]
          }
        ]
      },
      tl: /* [] */0
    };
    continue ;
  };
}

function frontend(opts, pre_forms) {
  return Comptypes.compMap((function (param) {
                var match = param._0;
                var expr = match[3];
                var helpers = match[2];
                var expr_names = Curry._1(Comptypes.StringSet.of_list, collect_used_names_bodyForm(expr));
                var helper_map = Comptypes.StringMapBuilder.go(List.map((function (h) {
                            return [
                                    Comptypes.name_of_helperform(h),
                                    h
                                  ];
                          }), helpers));
                var helper_names = calculate_live_helpers(opts, Comptypes.StringSet.empty, expr_names, helper_map);
                var live_helpers = List.filter(function (h) {
                        return Curry._2(Comptypes.StringSet.mem, Comptypes.name_of_helperform(h), helper_names);
                      })(helpers);
                return /* Mod */{
                        _0: [
                          match[0],
                          match[1],
                          List.rev(live_helpers),
                          expr
                        ]
                      };
              }), Comptypes.compMap(Rename.rename_children_compileform, Comptypes.compBind((function (m) {
                        if (m.TAG === /* ModAccum */0) {
                          return {
                                  TAG: /* CompileError */1,
                                  _0: m._0[0],
                                  _1: "mod must end on expression"
                                };
                        } else {
                          return {
                                  TAG: /* CompileOk */0,
                                  _0: m._0
                                };
                        }
                      }), frontend_start(opts, pre_forms))));
}

exports.collect_used_names_sexp = collect_used_names_sexp;
exports.collect_used_names_binding = collect_used_names_binding;
exports.collect_used_names_bodyForm = collect_used_names_bodyForm;
exports.collect_used_names_helperForm = collect_used_names_helperForm;
exports.collect_used_names_compileForm = collect_used_names_compileForm;
exports.calculate_live_helpers = calculate_live_helpers;
exports.qq_to_expression = qq_to_expression;
exports.qq_to_expression_list = qq_to_expression_list;
exports.args_to_expression_list = args_to_expression_list;
exports.compile_bodyform = compile_bodyform;
exports.compile_defconstant = compile_defconstant;
exports.compile_defun = compile_defun;
exports.compile_defmacro = compile_defmacro;
exports.compile_helperform = compile_helperform;
exports.compile_mod_ = compile_mod_;
exports.frontend_start = frontend_start;
exports.frontend = frontend;
/* Sexp Not a pure module */
