// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var $$Set = require("bs-platform/lib/js/set.js");
var List = require("bs-platform/lib/js/list.js");
var Sexp = require("./sexp.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");

var StringSet = $$Set.Make({
      compare: $$String.compare
    });

var StringMap = $$Map.Make({
      compare: $$String.compare
    });

function compMap(f, a) {
  if (a.TAG === /* CompileOk */0) {
    return {
            TAG: /* CompileOk */0,
            _0: Curry._1(f, a._0)
          };
  } else {
    return {
            TAG: /* CompileError */1,
            _0: a._0,
            _1: a._1
          };
  }
}

function compBind(f, a) {
  if (a.TAG === /* CompileOk */0) {
    return Curry._1(f, a._0);
  } else {
    return {
            TAG: /* CompileError */1,
            _0: a._0,
            _1: a._1
          };
  }
}

function identity(a) {
  return a;
}

function $$const(v, param) {
  return v;
}

function MapBuilder(S) {
  var go = function (lst) {
    return List.fold_left((function (coll, param) {
                  return Curry._3(S.add, param[0], param[1], coll);
                }), S.empty, lst);
  };
  return {
          go: go
        };
}

function go(lst) {
  return List.fold_left((function (coll, param) {
                return Curry._3(StringMap.add, param[0], param[1], coll);
              }), StringMap.empty, lst);
}

var StringMapBuilder = {
  go: go
};

function list_to_cons_(l, loc_of, _accum, _param) {
  while(true) {
    var param = _param;
    var accum = _accum;
    if (!param) {
      return Curry._1(accum, {
                  TAG: /* Nil */0,
                  _0: l
                });
    }
    var hd = param.hd;
    _param = param.tl;
    _accum = (function(accum,hd){
    return function (t) {
      return Curry._1(accum, {
                  TAG: /* Cons */1,
                  _0: [
                    Curry._1(loc_of, hd),
                    hd,
                    t
                  ]
                });
    }
    }(accum,hd));
    continue ;
  };
}

function list_to_cons(l, loc_of) {
  return function (param) {
    return list_to_cons_(l, loc_of, identity, param);
  };
}

function binding_to_sexp(l, body_to_sexp, param) {
  var match = param._0;
  var loc = match[0];
  return {
          TAG: /* Cons */1,
          _0: [
            loc,
            {
              TAG: /* Atom */4,
              _0: [
                loc,
                match[1]
              ]
            },
            {
              TAG: /* Cons */1,
              _0: [
                loc,
                bodyform_to_sexp(l, body_to_sexp, match[2]),
                {
                  TAG: /* Nil */0,
                  _0: loc
                }
              ]
            }
          ]
        };
}

function bodyform_to_sexp(l, body_to_sexp, body) {
  switch (body.TAG | 0) {
    case /* Let */0 :
        var match = body._0;
        var loc = match[0];
        var binding_translator = function (param) {
          return binding_to_sexp(l, body_to_sexp, param);
        };
        var translated_bindings = List.map(binding_translator, match[1]);
        var bindings_cons = list_to_cons(l, Sexp.location_of)(translated_bindings);
        var translated_body = bodyform_to_sexp(l, body_to_sexp, match[2]);
        return {
                TAG: /* Cons */1,
                _0: [
                  loc,
                  {
                    TAG: /* Atom */4,
                    _0: [
                      loc,
                      "let"
                    ]
                  },
                  {
                    TAG: /* Cons */1,
                    _0: [
                      loc,
                      bindings_cons,
                      {
                        TAG: /* Cons */1,
                        _0: [
                          loc,
                          translated_body,
                          {
                            TAG: /* Nil */0,
                            _0: loc
                          }
                        ]
                      }
                    ]
                  }
                ]
              };
    case /* Quoted */1 :
        var body$1 = body._0;
        var loc$1 = Sexp.location_of(body$1);
        return {
                TAG: /* Cons */1,
                _0: [
                  loc$1,
                  {
                    TAG: /* Atom */4,
                    _0: [
                      loc$1,
                      "q"
                    ]
                  },
                  body$1
                ]
              };
    case /* Value */2 :
        return body._0;
    case /* Call */3 :
        var match$1 = body._0;
        var l$1 = match$1[0];
        return list_to_cons(l$1, Sexp.location_of)(List.map((function (param) {
                          return bodyform_to_sexp(l$1, identity, param);
                        }), match$1[1]));
    
  }
}

function loc_of_bodyform(a) {
  switch (a.TAG | 0) {
    case /* Quoted */1 :
    case /* Value */2 :
        return Sexp.location_of(a._0);
    case /* Let */0 :
    case /* Call */3 :
        return a._0[0];
    
  }
}

function loc_of_binding(param) {
  return param._0[0];
}

function loc_of_compileform(param) {
  return param._0[0];
}

function loc_of_helperform(param) {
  return param._0[0];
}

function name_of_helperform(param) {
  return param._0[1];
}

function helperform_to_sexp(arg_to_sexp, body_to_sexp, param) {
  switch (param.TAG | 0) {
    case /* Defconstant */0 :
        var match = param._0;
        var l = match[0];
        return {
                TAG: /* Cons */1,
                _0: [
                  l,
                  {
                    TAG: /* Atom */4,
                    _0: [
                      l,
                      "defconstant"
                    ]
                  },
                  {
                    TAG: /* Cons */1,
                    _0: [
                      l,
                      {
                        TAG: /* Atom */4,
                        _0: [
                          l,
                          match[1]
                        ]
                      },
                      {
                        TAG: /* Cons */1,
                        _0: [
                          l,
                          bodyform_to_sexp(l, body_to_sexp, match[2]),
                          {
                            TAG: /* Nil */0,
                            _0: l
                          }
                        ]
                      }
                    ]
                  }
                ]
              };
    case /* Defmacro */1 :
        var match$1 = param._0;
        var l$1 = match$1[0];
        return {
                TAG: /* Cons */1,
                _0: [
                  l$1,
                  {
                    TAG: /* Atom */4,
                    _0: [
                      l$1,
                      "defmacro"
                    ]
                  },
                  {
                    TAG: /* Cons */1,
                    _0: [
                      l$1,
                      {
                        TAG: /* Atom */4,
                        _0: [
                          l$1,
                          match$1[1]
                        ]
                      },
                      {
                        TAG: /* Cons */1,
                        _0: [
                          l$1,
                          Curry._1(arg_to_sexp, match$1[2]),
                          {
                            TAG: /* Cons */1,
                            _0: [
                              l$1,
                              compileform_to_sexp(arg_to_sexp, body_to_sexp, match$1[3]),
                              {
                                TAG: /* Nil */0,
                                _0: l$1
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              };
    case /* Defun */2 :
        var match$2 = param._0;
        var l$2 = match$2[0];
        return {
                TAG: /* Cons */1,
                _0: [
                  l$2,
                  {
                    TAG: /* Atom */4,
                    _0: [
                      l$2,
                      match$2[2] ? "defun-inline" : "defun"
                    ]
                  },
                  {
                    TAG: /* Cons */1,
                    _0: [
                      l$2,
                      {
                        TAG: /* Atom */4,
                        _0: [
                          l$2,
                          match$2[1]
                        ]
                      },
                      {
                        TAG: /* Cons */1,
                        _0: [
                          l$2,
                          Curry._1(arg_to_sexp, match$2[3]),
                          {
                            TAG: /* Cons */1,
                            _0: [
                              l$2,
                              bodyform_to_sexp(l$2, body_to_sexp, match$2[4]),
                              {
                                TAG: /* Nil */0,
                                _0: l$2
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              };
    
  }
}

function compileform_to_sexp(arg_to_sexp, body_to_sexp, param) {
  var match = param._0;
  var l = match[0];
  var fcvt = function (param) {
    return helperform_to_sexp(arg_to_sexp, body_to_sexp, param);
  };
  var bcvt = bodyform_to_sexp(l, body_to_sexp, match[3]);
  return {
          TAG: /* Cons */1,
          _0: [
            l,
            {
              TAG: /* Atom */4,
              _0: [
                l,
                "mod"
              ]
            },
            {
              TAG: /* Cons */1,
              _0: [
                l,
                Curry._1(arg_to_sexp, match[1]),
                list_to_cons(l, Sexp.location_of)(List.concat({
                          hd: List.map(fcvt, match[2]),
                          tl: {
                            hd: {
                              hd: bcvt,
                              tl: /* [] */0
                            },
                            tl: /* [] */0
                          }
                        }))
              ]
            }
          ]
        };
}

function loc_of_code(param) {
  return param._0;
}

function with_heading(l, name, body) {
  return {
          TAG: /* Cons */1,
          _0: [
            l,
            {
              TAG: /* Atom */4,
              _0: [
                l,
                name
              ]
            },
            body
          ]
        };
}

function cons_of_string_map(l, cvt_body, map) {
  return list_to_cons(l, Sexp.location_of)(List.map((function (param) {
                    return {
                            TAG: /* Cons */1,
                            _0: [
                              l,
                              {
                                TAG: /* QuotedString */3,
                                _0: [
                                  l,
                                  /* '"' */34,
                                  param[0]
                                ]
                              },
                              {
                                TAG: /* Cons */1,
                                _0: [
                                  l,
                                  Curry._1(cvt_body, param[1]),
                                  {
                                    TAG: /* Nil */0,
                                    _0: l
                                  }
                                ]
                              }
                            ]
                          };
                  }), Curry._1(StringMap.bindings, map)));
}

exports.StringSet = StringSet;
exports.StringMap = StringMap;
exports.compMap = compMap;
exports.compBind = compBind;
exports.identity = identity;
exports.$$const = $$const;
exports.MapBuilder = MapBuilder;
exports.StringMapBuilder = StringMapBuilder;
exports.list_to_cons_ = list_to_cons_;
exports.list_to_cons = list_to_cons;
exports.binding_to_sexp = binding_to_sexp;
exports.loc_of_bodyform = loc_of_bodyform;
exports.loc_of_binding = loc_of_binding;
exports.bodyform_to_sexp = bodyform_to_sexp;
exports.loc_of_compileform = loc_of_compileform;
exports.loc_of_helperform = loc_of_helperform;
exports.name_of_helperform = name_of_helperform;
exports.helperform_to_sexp = helperform_to_sexp;
exports.compileform_to_sexp = compileform_to_sexp;
exports.loc_of_code = loc_of_code;
exports.with_heading = with_heading;
exports.cons_of_string_map = cons_of_string_map;
/* StringSet Not a pure module */
