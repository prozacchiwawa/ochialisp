// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Clvm = require("./clvm.js");
var List = require("bs-platform/lib/js/list.js");
var Sexp = require("./sexp.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Prims = require("./prims.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Srcloc = require("./srcloc.js");
var $$String = require("bs-platform/lib/js/string.js");
var Frontend = require("./frontend.js");
var Runtypes = require("./runtypes.js");
var Comptypes = require("./comptypes.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");

function compute_code_shape(l, helpers) {
  var build_tree = function (s, e, helper_array) {
    if ((e - s | 0) === 1) {
      var h = Caml_array.get(helper_array, s);
      return {
              TAG: /* Atom */4,
              _0: [
                Comptypes.loc_of_helperform(h),
                Comptypes.name_of_helperform(h)
              ]
            };
    }
    var mid = (e + s | 0) / 2 | 0;
    var car = build_tree(s, mid, helper_array);
    var cdr = build_tree(mid, e, helper_array);
    return {
            TAG: /* Cons */1,
            _0: [
              l,
              car,
              cdr
            ]
          };
  };
  var array = $$Array.of_list(helpers);
  var alen = array.length;
  if (alen === 0) {
    return {
            TAG: /* Nil */0,
            _0: l
          };
  } else if (alen === 1) {
    return {
            TAG: /* Atom */4,
            _0: [
              l,
              Comptypes.name_of_helperform(Caml_array.get(array, 0))
            ]
          };
  } else {
    return build_tree(0, alen, array);
  }
}

function compute_env_shape(l, args, helpers) {
  var car = compute_code_shape(l, helpers);
  return {
          TAG: /* Cons */1,
          _0: [
            l,
            car,
            args
          ]
        };
}

function create_name_lookup_(l, name, env, any) {
  switch (any.TAG | 0) {
    case /* Cons */1 :
        var match = any._0;
        var l$1 = match[0];
        var v = create_name_lookup_(l$1, name, env, match[1]);
        if (v.TAG === /* CompileOk */0) {
          return {
                  TAG: /* CompileOk */0,
                  _0: (v._0 << 1)
                };
        } else {
          return Comptypes.compMap((function (v) {
                        return (v << 1) + 1 | 0;
                      }), create_name_lookup_(l$1, name, env, match[2]));
        }
    case /* Atom */4 :
        var match$1 = any._0;
        var a = match$1[1];
        if (a === name) {
          return {
                  TAG: /* CompileOk */0,
                  _0: 1
                };
        } else {
          return {
                  TAG: /* CompileError */1,
                  _0: match$1[0],
                  _1: Curry._2(Printf.sprintf(/* Format */{
                            _0: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: " not found (via ",
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* Char_literal */12,
                                    _0: /* ')' */41,
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            },
                            _1: "%s not found (via %s)"
                          }), name, a)
                };
        }
    default:
      return {
              TAG: /* CompileError */1,
              _0: l,
              _1: Curry._3(Printf.sprintf(/* Format */{
                        _0: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: " not found checking ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: " in ",
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        },
                        _1: "%s not found checking %s in %s"
                      }), name, Sexp.to_string(any), Sexp.to_string(env))
            };
  }
}

function create_name_lookup(compiler, l, name) {
  try {
    return {
            TAG: /* CompileOk */0,
            _0: Curry._2(Comptypes.StringMap.find, name, compiler.constants)
          };
  }
  catch (exn){
    return Comptypes.compMap((function (i) {
                  return {
                          TAG: /* Integer */2,
                          _0: [
                            l,
                            String(i)
                          ]
                        };
                }), create_name_lookup_(l, name, compiler.env, compiler.env));
  }
}

function lookup_prim(compiler, l, name) {
  try {
    return {
            TAG: /* CompileOk */0,
            _0: Curry._2(Comptypes.StringMap.find, name, compiler.prims)
          };
  }
  catch (exn){
    return {
            TAG: /* CompileError */1,
            _0: l,
            _1: "no such prim " + name
          };
  }
}

function codegen_to_sexp(opts, compiler) {
  var l = Srcloc.start(opts.filename);
  return Comptypes.with_heading(l, "codegen", Comptypes.list_to_cons(l, Sexp.location_of)({
                  hd: Comptypes.with_heading(l, "prims", Comptypes.cons_of_string_map(l, Comptypes.identity, compiler.prims)),
                  tl: {
                    hd: Comptypes.with_heading(l, "macros", Comptypes.cons_of_string_map(l, Comptypes.identity, compiler.macros)),
                    tl: {
                      hd: Comptypes.with_heading(l, "defuns", Comptypes.cons_of_string_map(l, (function (dc) {
                                  return {
                                          TAG: /* Cons */1,
                                          _0: [
                                            l,
                                            dc.requiredEnv,
                                            {
                                              TAG: /* Cons */1,
                                              _0: [
                                                l,
                                                dc.code,
                                                {
                                                  TAG: /* Nil */0,
                                                  _0: l
                                                }
                                              ]
                                            }
                                          ]
                                        };
                                }), compiler.defuns)),
                      tl: {
                        hd: Comptypes.with_heading(l, "to_process", Comptypes.list_to_cons(l, Sexp.location_of)(List.map((function (h) {
                                        return {
                                                TAG: /* Atom */4,
                                                _0: [
                                                  l,
                                                  Comptypes.name_of_helperform(h)
                                                ]
                                              };
                                      }), compiler.to_process))),
                        tl: {
                          hd: Comptypes.with_heading(l, "env", {
                                TAG: /* Cons */1,
                                _0: [
                                  l,
                                  compiler.env,
                                  {
                                    TAG: /* Nil */0,
                                    _0: l
                                  }
                                ]
                              }),
                          tl: {
                            hd: Comptypes.with_heading(l, "final_expr", {
                                  TAG: /* Cons */1,
                                  _0: [
                                    l,
                                    Comptypes.bodyform_to_sexp(l, Comptypes.identity, compiler.final_expr),
                                    {
                                      TAG: /* Nil */0,
                                      _0: l
                                    }
                                  ]
                                }),
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                }));
}

function get_callable(_opts, compiler, _l, atom) {
  switch (atom.TAG | 0) {
    case /* Integer */2 :
        var match = atom._0;
        return {
                TAG: /* CompileOk */0,
                _0: {
                  TAG: /* CallPrim */2,
                  _0: {
                    TAG: /* Integer */2,
                    _0: [
                      match[0],
                      match[1]
                    ]
                  }
                }
              };
    case /* Atom */4 :
        var match$1 = atom._0;
        var name = match$1[1];
        var l = match$1[0];
        var macro;
        try {
          macro = Curry._2(Comptypes.StringMap.find, name, compiler.macros);
        }
        catch (exn){
          macro = undefined;
        }
        var defun = create_name_lookup(compiler, l, name);
        var prim;
        try {
          prim = Curry._2(Comptypes.StringMap.find, name, compiler.prims);
        }
        catch (exn$1){
          prim = undefined;
        }
        if (macro !== undefined) {
          return {
                  TAG: /* CompileOk */0,
                  _0: {
                    TAG: /* CallMacro */0,
                    _0: macro
                  }
                };
        }
        if (defun.TAG === /* CompileOk */0) {
          return {
                  TAG: /* CompileOk */0,
                  _0: {
                    TAG: /* CallDefun */1,
                    _0: defun._0
                  }
                };
        }
        if (prim !== undefined) {
          return {
                  TAG: /* CompileOk */0,
                  _0: {
                    TAG: /* CallPrim */2,
                    _0: prim
                  }
                };
        }
        if (atom.TAG === /* Atom */4 && atom._0[1] === "com") {
          return {
                  TAG: /* CompileOk */0,
                  _0: /* RunCompiler */0
                };
        }
        return {
                TAG: /* CompileError */1,
                _0: l,
                _1: "no such callable '" + (name + "'")
              };
    default:
      return {
              TAG: /* CompileError */1,
              _0: Sexp.location_of(atom),
              _1: "can't call object " + Sexp.to_string(atom)
            };
  }
}

function generate_args_code(opts, compiler, l, param) {
  if (!param) {
    return {
            TAG: /* CompileOk */0,
            _0: {
              TAG: /* Nil */0,
              _0: l
            }
          };
  }
  var hd = param.hd;
  return Comptypes.compBind((function (t) {
                return Comptypes.compMap((function (param) {
                              return {
                                      TAG: /* Cons */1,
                                      _0: [
                                        l,
                                        param._1,
                                        t
                                      ]
                                    };
                            }), generate_expr_code(opts, compiler, hd));
              }), generate_args_code(opts, compiler, l, param.tl));
}

function process_defun_call(_opts, _compiler, l, args, lookup) {
  var cons_up = function (any) {
    if (any.TAG !== /* Cons */1) {
      return any;
    }
    var match = any._0;
    return Prims.primcons(match[0], match[1], cons_up(match[2]));
  };
  var env = Prims.primcons(l, {
        TAG: /* Integer */2,
        _0: [
          l,
          "2"
        ]
      }, cons_up(args));
  return {
          TAG: /* CompileOk */0,
          _0: /* Code */{
            _0: l,
            _1: Prims.primapply(l, lookup, env)
          }
        };
}

function process_macro_call(opts, compiler, l, args, code) {
  var converted_args = List.map((function (param) {
          return Comptypes.bodyform_to_sexp(l, Comptypes.identity, param);
        }), args);
  var args_to_macro = Comptypes.list_to_cons(l, Sexp.location_of)(converted_args);
  var run_outcome = Clvm.run(code, args_to_macro);
  switch (run_outcome.TAG | 0) {
    case /* RunError */0 :
        var match = run_outcome._0;
        return {
                TAG: /* CompileError */1,
                _0: l,
                _1: Curry._2(Printf.sprintf(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "error executing macro: ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* ' ' */32,
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          },
                          _1: "error executing macro: %s %s"
                        }), Srcloc.toString(match[0]), match[1])
              };
    case /* RunExn */1 :
        var match$1 = run_outcome._0;
        return {
                TAG: /* CompileError */1,
                _0: l,
                _1: Curry._2(Printf.sprintf(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "macro aborted at ",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: " with ",
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          },
                          _1: "macro aborted at %s with %s"
                        }), Srcloc.toString(match$1[0]), Sexp.to_string(match$1[1]))
              };
    case /* RunOk */2 :
        return Comptypes.compBind((function (body) {
                      return generate_expr_code(opts, compiler, body);
                    }), Frontend.compile_bodyform(run_outcome._0));
    
  }
}

function combine_defun_env(old_env, new_args) {
  if (old_env.TAG !== /* Cons */1) {
    return old_env;
  }
  var match = old_env._0;
  return {
          TAG: /* Cons */1,
          _0: [
            match[0],
            match[1],
            new_args
          ]
        };
}

function generate_expr_code(opts, compiler, expr) {
  switch (expr.TAG | 0) {
    case /* Let */0 :
        return {
                TAG: /* CompileError */1,
                _0: expr._0[0],
                _1: "can't yet do let"
              };
    case /* Quoted */1 :
        var q = expr._0;
        var l = Sexp.location_of(q);
        return {
                TAG: /* CompileOk */0,
                _0: /* Code */{
                  _0: l,
                  _1: Prims.primquote(l, q)
                }
              };
    case /* Value */2 :
        var x = expr._0;
        if (x.TAG !== /* Atom */4) {
          return {
                  TAG: /* CompileOk */0,
                  _0: /* Code */{
                    _0: Sexp.location_of(x),
                    _1: Prims.primquote(Sexp.location_of(x), x)
                  }
                };
        }
        var match = x._0;
        var v = match[1];
        var l$1 = match[0];
        if (v === "@") {
          return {
                  TAG: /* CompileOk */0,
                  _0: /* Code */{
                    _0: l$1,
                    _1: {
                      TAG: /* Integer */2,
                      _0: [
                        l$1,
                        "1"
                      ]
                    }
                  }
                };
        } else {
          return Comptypes.compMap((function (f) {
                        return /* Code */{
                                _0: l$1,
                                _1: f
                              };
                      }), create_name_lookup(compiler, l$1, v));
        }
    case /* Call */3 :
        var match$1 = expr._0;
        var match$2 = match$1[1];
        var l$2 = match$1[0];
        if (!match$2) {
          return {
                  TAG: /* CompileError */1,
                  _0: l$2,
                  _1: "created a call with no forms"
                };
        }
        var match$3 = match$2.hd;
        if (match$3.TAG === /* Value */2) {
          var match$4 = match$3._0;
          if (match$4.TAG === /* Atom */4) {
            var tl = match$2.tl;
            var match$5 = match$4._0;
            return Comptypes.compBind((function (code) {
                          if (typeof code === "number") {
                            if (tl && !tl.tl) {
                              var opts_includeDirs = opts.includeDirs;
                              var opts_filename = opts.filename;
                              var opts_readNewFile = opts.readNewFile;
                              var opts_compiler = compiler;
                              var opts_compileProgram = opts.compileProgram;
                              var opts_startEnv = opts.startEnv;
                              var opts$1 = {
                                includeDirs: opts_includeDirs,
                                filename: opts_filename,
                                readNewFile: opts_readNewFile,
                                compiler: opts_compiler,
                                compileProgram: opts_compileProgram,
                                inDefun: true,
                                assemble: false,
                                stdenv: false,
                                startEnv: opts_startEnv
                              };
                              var use_body = {
                                TAG: /* Cons */1,
                                _0: [
                                  l$2,
                                  {
                                    TAG: /* Atom */4,
                                    _0: [
                                      l$2,
                                      "mod"
                                    ]
                                  },
                                  {
                                    TAG: /* Cons */1,
                                    _0: [
                                      l$2,
                                      {
                                        TAG: /* Nil */0,
                                        _0: l$2
                                      },
                                      {
                                        TAG: /* Cons */1,
                                        _0: [
                                          l$2,
                                          Comptypes.bodyform_to_sexp(l$2, Comptypes.identity, tl.hd),
                                          {
                                            TAG: /* Nil */0,
                                            _0: l$2
                                          }
                                        ]
                                      }
                                    ]
                                  }
                                ]
                              };
                              return Comptypes.compMap((function (code) {
                                            return /* Code */{
                                                    _0: l$2,
                                                    _1: Prims.primquote(l$2, code)
                                                  };
                                          }), Curry._2(opts_compileProgram, opts$1, use_body));
                            }
                            return {
                                    TAG: /* CompileError */1,
                                    _0: l$2,
                                    _1: Curry._1(Printf.sprintf(/* Format */{
                                              _0: {
                                                TAG: /* String_literal */11,
                                                _0: "wierdly formed compile request: ",
                                                _1: {
                                                  TAG: /* String */2,
                                                  _0: /* No_padding */0,
                                                  _1: /* End_of_format */0
                                                }
                                              },
                                              _1: "wierdly formed compile request: %s"
                                            }), $$String.concat(";", List.map(Sexp.to_string, List.map((function (param) {
                                                        return Comptypes.bodyform_to_sexp(l$2, Comptypes.identity, param);
                                                      }), tl))))
                                  };
                          }
                          switch (code.TAG | 0) {
                            case /* CallMacro */0 :
                                return process_macro_call(opts, compiler, l$2, tl, code._0);
                            case /* CallDefun */1 :
                                var lookup = code._0;
                                return Comptypes.compBind((function (args) {
                                              return process_defun_call(opts, compiler, l$2, args, lookup);
                                            }), generate_args_code(opts, compiler, l$2, tl));
                            case /* CallPrim */2 :
                                var p = code._0;
                                return Comptypes.compBind((function (args) {
                                              return {
                                                      TAG: /* CompileOk */0,
                                                      _0: /* Code */{
                                                        _0: l$2,
                                                        _1: {
                                                          TAG: /* Cons */1,
                                                          _0: [
                                                            l$2,
                                                            p,
                                                            args
                                                          ]
                                                        }
                                                      }
                                                    };
                                            }), generate_args_code(opts, compiler, l$2, tl));
                            
                          }
                        }), get_callable(opts, compiler, l$2, {
                            TAG: /* Atom */4,
                            _0: [
                              match$5[0],
                              match$5[1]
                            ]
                          }));
          }
          
        }
        break;
    
  }
  return {
          TAG: /* CompileError */1,
          _0: Comptypes.loc_of_bodyform(expr),
          _1: "don't know how to compile " + Sexp.to_string(Comptypes.bodyform_to_sexp(Comptypes.loc_of_bodyform(expr), Comptypes.identity, expr))
        };
}

function empty_compiler(l) {
  return {
          prims: Comptypes.StringMapBuilder.go(Prims.prims),
          constants: Comptypes.StringMap.empty,
          macros: Comptypes.StringMap.empty,
          defuns: Comptypes.StringMap.empty,
          parentfns: Comptypes.StringSet.empty,
          env: {
            TAG: /* Cons */1,
            _0: [
              l,
              {
                TAG: /* Nil */0,
                _0: l
              },
              {
                TAG: /* Nil */0,
                _0: l
              }
            ]
          },
          to_process: /* [] */0,
          final_expr: {
            TAG: /* Quoted */1,
            _0: {
              TAG: /* Nil */0,
              _0: l
            }
          },
          final_code: undefined
        };
}

function is_defun(param) {
  switch (param.TAG | 0) {
    case /* Defconstant */0 :
    case /* Defmacro */1 :
        return false;
    case /* Defun */2 :
        return true;
    
  }
}

function finalize_env_(opts, c, _l, env) {
  switch (env.TAG | 0) {
    case /* Cons */1 :
        var match = env._0;
        var r = match[2];
        var l = match[0];
        return Comptypes.compBind((function (h) {
                      return Comptypes.compMap((function (r) {
                                    return {
                                            TAG: /* Cons */1,
                                            _0: [
                                              l,
                                              h,
                                              r
                                            ]
                                          };
                                  }), finalize_env_(opts, c, l, r));
                    }), finalize_env_(opts, c, l, match[1]));
    case /* Atom */4 :
        var match$1 = env._0;
        var v = match$1[1];
        var l$1 = match$1[0];
        if (Curry._2(Comptypes.StringSet.mem, v, c.parentfns)) {
          return {
                  TAG: /* CompileOk */0,
                  _0: {
                    TAG: /* Nil */0,
                    _0: l$1
                  }
                };
        }
        try {
          return {
                  TAG: /* CompileOk */0,
                  _0: Curry._2(Comptypes.StringMap.find, v, c.defuns).code
                };
        }
        catch (exn){
          return {
                  TAG: /* CompileError */1,
                  _0: l$1,
                  _1: "A defun was referenced in the defun env but not found " + v
                };
        }
    default:
      return {
              TAG: /* CompileOk */0,
              _0: env
            };
  }
}

function final_codegen(opts, compiler) {
  return Comptypes.compMap((function (param) {
                return {
                        prims: compiler.prims,
                        constants: compiler.constants,
                        macros: compiler.macros,
                        defuns: compiler.defuns,
                        parentfns: compiler.parentfns,
                        env: compiler.env,
                        to_process: compiler.to_process,
                        final_expr: compiler.final_expr,
                        final_code: /* Code */{
                          _0: param._0,
                          _1: param._1
                        }
                      };
              }), generate_expr_code(opts, compiler, compiler.final_expr));
}

function finalize_env(opts, c) {
  var any = c.env;
  if (any.TAG !== /* Cons */1) {
    return {
            TAG: /* CompileOk */0,
            _0: any
          };
  }
  var match = any._0;
  return finalize_env_(opts, c, match[0], match[1]);
}

function start_codegen(opts, param) {
  var match = param._0;
  var helpers = match[2];
  var l = match[0];
  var live_helpers = List.filter(is_defun)(helpers);
  var c = opts.compiler;
  var use_compiler = c !== undefined ? c : empty_compiler(l);
  var env = opts.startEnv;
  return {
          prims: use_compiler.prims,
          constants: use_compiler.constants,
          macros: use_compiler.macros,
          defuns: use_compiler.defuns,
          parentfns: use_compiler.parentfns,
          env: env !== undefined ? env : compute_env_shape(l, match[1], live_helpers),
          to_process: helpers,
          final_expr: match[3],
          final_code: use_compiler.final_code
        };
}

function codegen_(opts, compiler, param) {
  switch (param.TAG | 0) {
    case /* Defconstant */0 :
        var match = param._0;
        var name = match[1];
        var loc = match[0];
        var expandProgram = Comptypes.compileform_to_sexp(Comptypes.identity, Comptypes.identity, /* Mod */{
              _0: [
                loc,
                {
                  TAG: /* Nil */0,
                  _0: loc
                },
                /* [] */0,
                match[2]
              ]
            });
        var opts_includeDirs = opts.includeDirs;
        var opts_filename = opts.filename;
        var opts_readNewFile = opts.readNewFile;
        var opts_compiler = compiler;
        var opts_compileProgram = opts.compileProgram;
        var opts_inDefun = opts.inDefun;
        var opts_assemble = opts.assemble;
        var opts_stdenv = opts.stdenv;
        var opts_startEnv = opts.startEnv;
        var opts$1 = {
          includeDirs: opts_includeDirs,
          filename: opts_filename,
          readNewFile: opts_readNewFile,
          compiler: opts_compiler,
          compileProgram: opts_compileProgram,
          inDefun: opts_inDefun,
          assemble: opts_assemble,
          stdenv: opts_stdenv,
          startEnv: opts_startEnv
        };
        return Comptypes.compMap((function (res) {
                      return {
                              prims: compiler.prims,
                              constants: Curry._3(Comptypes.StringMap.add, name, Prims.primquote(loc, res), compiler.constants),
                              macros: compiler.macros,
                              defuns: compiler.defuns,
                              parentfns: compiler.parentfns,
                              env: compiler.env,
                              to_process: compiler.to_process,
                              final_expr: compiler.final_expr,
                              final_code: compiler.final_code
                            };
                    }), Comptypes.compBind((function (code) {
                          var res = Clvm.run(code, {
                                TAG: /* Nil */0,
                                _0: loc
                              });
                          switch (res.TAG | 0) {
                            case /* RunError */0 :
                            case /* RunExn */1 :
                                break;
                            case /* RunOk */2 :
                                return {
                                        TAG: /* CompileOk */0,
                                        _0: res._0
                                      };
                            
                          }
                          return {
                                  TAG: /* CompileError */1,
                                  _0: loc,
                                  _1: Curry._1(Printf.sprintf(/* Format */{
                                            _0: {
                                              TAG: /* String_literal */11,
                                              _0: "Error evaluating constant: ",
                                              _1: {
                                                TAG: /* String */2,
                                                _0: /* No_padding */0,
                                                _1: /* End_of_format */0
                                              }
                                            },
                                            _1: "Error evaluating constant: %s"
                                          }), Runtypes.run_to_string(Sexp.to_string, res))
                                };
                        }), Curry._2(opts_compileProgram, opts$1, expandProgram)));
    case /* Defmacro */1 :
        var match$1 = param._0;
        var name$1 = match$1[1];
        var macroProgram = Comptypes.compileform_to_sexp(Comptypes.identity, Comptypes.identity, match$1[3]);
        var opts_includeDirs$1 = opts.includeDirs;
        var opts_filename$1 = opts.filename;
        var opts_readNewFile$1 = opts.readNewFile;
        var opts_compiler$1 = compiler;
        var opts_compileProgram$1 = opts.compileProgram;
        var opts_inDefun$1 = opts.inDefun;
        var opts_startEnv$1 = opts.startEnv;
        var opts$2 = {
          includeDirs: opts_includeDirs$1,
          filename: opts_filename$1,
          readNewFile: opts_readNewFile$1,
          compiler: opts_compiler$1,
          compileProgram: opts_compileProgram$1,
          inDefun: opts_inDefun$1,
          assemble: false,
          stdenv: false,
          startEnv: opts_startEnv$1
        };
        return Comptypes.compMap((function (code) {
                      return {
                              prims: compiler.prims,
                              constants: compiler.constants,
                              macros: Curry._3(Comptypes.StringMap.add, name$1, code, compiler.macros),
                              defuns: compiler.defuns,
                              parentfns: compiler.parentfns,
                              env: compiler.env,
                              to_process: compiler.to_process,
                              final_expr: compiler.final_expr,
                              final_code: compiler.final_code
                            };
                    }), Curry._2(opts_compileProgram$1, opts$2, macroProgram));
    case /* Defun */2 :
        var match$2 = param._0;
        var args = match$2[3];
        var name$2 = match$2[1];
        var loc$1 = match$2[0];
        var opts_includeDirs$2 = opts.includeDirs;
        var opts_filename$2 = opts.filename;
        var opts_readNewFile$2 = opts.readNewFile;
        var opts_compiler$2 = {
          prims: compiler.prims,
          constants: compiler.constants,
          macros: compiler.macros,
          defuns: compiler.defuns,
          parentfns: Curry._2(Comptypes.StringSet.add, name$2, compiler.parentfns),
          env: compiler.env,
          to_process: compiler.to_process,
          final_expr: compiler.final_expr,
          final_code: compiler.final_code
        };
        var opts_compileProgram$2 = opts.compileProgram;
        var opts_startEnv$2 = combine_defun_env(compiler.env, args);
        var opts$3 = {
          includeDirs: opts_includeDirs$2,
          filename: opts_filename$2,
          readNewFile: opts_readNewFile$2,
          compiler: opts_compiler$2,
          compileProgram: opts_compileProgram$2,
          inDefun: true,
          assemble: false,
          stdenv: false,
          startEnv: opts_startEnv$2
        };
        var tocompile = {
          TAG: /* Cons */1,
          _0: [
            loc$1,
            {
              TAG: /* Atom */4,
              _0: [
                loc$1,
                "mod"
              ]
            },
            {
              TAG: /* Cons */1,
              _0: [
                loc$1,
                args,
                {
                  TAG: /* Cons */1,
                  _0: [
                    loc$1,
                    Comptypes.bodyform_to_sexp(loc$1, Comptypes.identity, match$2[4]),
                    {
                      TAG: /* Nil */0,
                      _0: loc$1
                    }
                  ]
                }
              ]
            }
          ]
        };
        return Comptypes.compMap((function (code) {
                      return {
                              prims: compiler.prims,
                              constants: compiler.constants,
                              macros: compiler.macros,
                              defuns: Curry._3(Comptypes.StringMap.add, name$2, {
                                    requiredEnv: args,
                                    code: code
                                  }, compiler.defuns),
                              parentfns: compiler.parentfns,
                              env: compiler.env,
                              to_process: compiler.to_process,
                              final_expr: compiler.final_expr,
                              final_code: compiler.final_code
                            };
                    }), Curry._2(opts_compileProgram$2, opts$3, tocompile));
    
  }
}

function get_call_name(l, any) {
  if (any.TAG === /* Value */2) {
    var match = any._0;
    switch (match.TAG | 0) {
      case /* Integer */2 :
          var match$1 = match._0;
          return {
                  TAG: /* CompileOk */0,
                  _0: {
                    TAG: /* Integer */2,
                    _0: [
                      match$1[0],
                      match$1[1]
                    ]
                  }
                };
      case /* Atom */4 :
          var match$2 = match._0;
          return {
                  TAG: /* CompileOk */0,
                  _0: {
                    TAG: /* Atom */4,
                    _0: [
                      match$2[0],
                      match$2[1]
                    ]
                  }
                };
      default:
        
    }
  }
  return {
          TAG: /* CompileError */1,
          _0: l,
          _1: "not yet callable " + Sexp.to_string(Comptypes.bodyform_to_sexp(l, Comptypes.identity, any))
        };
}

function codegen(opts, cmod) {
  var compiler = start_codegen(opts, cmod);
  return Comptypes.compBind((function (c) {
                return Comptypes.compBind((function (final_env) {
                              var match = c.final_code;
                              if (match === undefined) {
                                return {
                                        TAG: /* CompileError */1,
                                        _0: Srcloc.start(opts.filename),
                                        _1: "Failed to generate code"
                                      };
                              }
                              var code = match._1;
                              var l = match._0;
                              if (opts.inDefun) {
                                var final_code = Prims.primapply(l, Prims.primquote(l, code), {
                                      TAG: /* Integer */2,
                                      _0: [
                                        l,
                                        "1"
                                      ]
                                    });
                                return {
                                        TAG: /* CompileOk */0,
                                        _0: final_code
                                      };
                              }
                              var final_code$1 = Prims.primapply(l, Prims.primquote(l, code), Prims.primcons(l, Prims.primquote(l, final_env), {
                                        TAG: /* Integer */2,
                                        _0: [
                                          l,
                                          "1"
                                        ]
                                      }));
                              return {
                                      TAG: /* CompileOk */0,
                                      _0: final_code$1
                                    };
                            }), finalize_env(opts, c));
              }), Comptypes.compBind((function (param) {
                    return final_codegen(opts, param);
                  }), List.fold_left((function (c, f) {
                        return Comptypes.compBind((function (comp) {
                                      return codegen_(opts, comp, f);
                                    }), c);
                      }), {
                      TAG: /* CompileOk */0,
                      _0: compiler
                    }, compiler.to_process)));
}

exports.compute_code_shape = compute_code_shape;
exports.compute_env_shape = compute_env_shape;
exports.create_name_lookup_ = create_name_lookup_;
exports.create_name_lookup = create_name_lookup;
exports.lookup_prim = lookup_prim;
exports.codegen_to_sexp = codegen_to_sexp;
exports.get_callable = get_callable;
exports.process_macro_call = process_macro_call;
exports.generate_args_code = generate_args_code;
exports.process_defun_call = process_defun_call;
exports.get_call_name = get_call_name;
exports.generate_expr_code = generate_expr_code;
exports.combine_defun_env = combine_defun_env;
exports.codegen_ = codegen_;
exports.is_defun = is_defun;
exports.empty_compiler = empty_compiler;
exports.start_codegen = start_codegen;
exports.final_codegen = final_codegen;
exports.finalize_env_ = finalize_env_;
exports.finalize_env = finalize_env;
exports.codegen = codegen;
/* Clvm Not a pure module */
