// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Hash = require("./hash.js");
var List = require("bs-platform/lib/js/list.js");
var Sexp = require("./sexp.js");
var Arith = require("./arith.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Prims = require("./prims.js");
var Srcloc = require("./srcloc.js");
var $$String = require("bs-platform/lib/js/string.js");
var Binascii = require("binascii");

function choose_path(_l, orig, _p, all, _context) {
  while(true) {
    var context = _context;
    var p = _p;
    var l = _l;
    if (p === 1) {
      return {
              TAG: /* RunOk */2,
              _0: context
            };
    }
    if (context.TAG !== /* Cons */1) {
      return {
              TAG: /* RunError */0,
              _0: [
                l,
                "bad path " + (String(orig) + (" in " + Sexp.to_string(all)))
              ]
            };
    }
    var match = context._0;
    var next = p % 2 === 0 ? match[1] : match[2];
    _context = next;
    _p = p / 2 | 0;
    _l = match[0];
    continue ;
  };
}

function runMap(f, e) {
  switch (e.TAG | 0) {
    case /* RunError */0 :
        var match = e._0;
        return {
                TAG: /* RunError */0,
                _0: [
                  match[0],
                  match[1]
                ]
              };
    case /* RunExn */1 :
        var match$1 = e._0;
        return {
                TAG: /* RunExn */1,
                _0: [
                  match$1[0],
                  match$1[1]
                ]
              };
    case /* RunOk */2 :
        return {
                TAG: /* RunOk */2,
                _0: Curry._1(f, e._0)
              };
    
  }
}

function runBind(f, e) {
  switch (e.TAG | 0) {
    case /* RunError */0 :
        var match = e._0;
        return {
                TAG: /* RunError */0,
                _0: [
                  match[0],
                  match[1]
                ]
              };
    case /* RunExn */1 :
        var match$1 = e._0;
        return {
                TAG: /* RunExn */1,
                _0: [
                  match$1[0],
                  match$1[1]
                ]
              };
    case /* RunOk */2 :
        return Curry._1(f, e._0);
    
  }
}

function cvt_to_string(l, any) {
  switch (any.TAG | 0) {
    case /* Nil */0 :
        return {
                TAG: /* RunOk */2,
                _0: ""
              };
    case /* Cons */1 :
        return {
                TAG: /* RunError */0,
                _0: [
                  l,
                  "bad argument to >s " + Sexp.to_string(any)
                ]
              };
    case /* Integer */2 :
        return {
                TAG: /* RunOk */2,
                _0: Binascii.unhexlify(Sexp.encode_int_to_bigint(any._0[1]))
              };
    case /* QuotedString */3 :
        return {
                TAG: /* RunOk */2,
                _0: any._0[2]
              };
    case /* Atom */4 :
        return {
                TAG: /* RunOk */2,
                _0: any._0[1]
              };
    
  }
}

function cvt_to_int(l, any) {
  switch (any.TAG | 0) {
    case /* Nil */0 :
        return {
                TAG: /* RunOk */2,
                _0: 0
              };
    case /* Cons */1 :
        return {
                TAG: /* RunError */0,
                _0: [
                  l,
                  "bad argument for int conversion " + Sexp.to_string(any)
                ]
              };
    case /* Integer */2 :
        return {
                TAG: /* RunOk */2,
                _0: Sexp.intval(any._0[1])
              };
    case /* QuotedString */3 :
        return {
                TAG: /* RunOk */2,
                _0: Sexp.intval("0x" + Sexp.encode_string_to_bigint(any._0[2]))
              };
    case /* Atom */4 :
        return {
                TAG: /* RunOk */2,
                _0: Sexp.intval("0x" + Sexp.encode_string_to_bigint(any._0[1]))
              };
    
  }
}

function run(_sexp, context) {
  while(true) {
    var sexp = _sexp;
    var translate_head = function (sexp) {
      switch (sexp.TAG | 0) {
        case /* Nil */0 :
            return {
                    TAG: /* RunError */0,
                    _0: [
                      sexp._0,
                      "cannot apply nil"
                    ]
                  };
        case /* Cons */1 :
            var match = sexp._0;
            var l1 = match[2];
            if (l1.TAG === /* Nil */0) {
              return run({
                          TAG: /* Cons */1,
                          _0: [
                            match[0],
                            match[1],
                            {
                              TAG: /* Nil */0,
                              _0: l1._0
                            }
                          ]
                        }, context);
            }
            break;
        case /* Integer */2 :
            return {
                    TAG: /* RunOk */2,
                    _0: sexp
                  };
        case /* QuotedString */3 :
            break;
        case /* Atom */4 :
            var match$1 = sexp._0;
            var v = match$1[1];
            var matching_ops = List.filter(function (param) {
                    return param[0] === v;
                  })(Prims.prims);
            if (matching_ops) {
              return {
                      TAG: /* RunOk */2,
                      _0: matching_ops.hd[1]
                    };
            } else {
              return {
                      TAG: /* RunError */0,
                      _0: [
                        match$1[0],
                        "Can't find operator '" + (v + "'")
                      ]
                    };
            }
        
      }
      return {
              TAG: /* RunError */0,
              _0: [
                Sexp.location_of(sexp),
                "Unexpected head form in clvm " + Sexp.to_string(sexp)
              ]
            };
    };
    var eval_args = function (args) {
      switch (args.TAG | 0) {
        case /* Nil */0 :
            return {
                    TAG: /* RunOk */2,
                    _0: {
                      TAG: /* Nil */0,
                      _0: args._0
                    }
                  };
        case /* Cons */1 :
            var match = args._0;
            var b = match[2];
            var l = match[0];
            return runBind((function (aval) {
                          return runMap((function (atail) {
                                        return {
                                                TAG: /* Cons */1,
                                                _0: [
                                                  l,
                                                  aval,
                                                  atail
                                                ]
                                              };
                                      }), eval_args(b));
                        }), run(match[1], context));
        default:
          return {
                  TAG: /* RunError */0,
                  _0: [
                    Sexp.location_of(args),
                    "bad argument list"
                  ]
                };
      }
    };
    var apply_op = function (l, head, args) {
      if (head.TAG !== /* Integer */2) {
        return {
                TAG: /* RunError */0,
                _0: [
                  l,
                  "bad op " + (Sexp.to_string(head) + (" with args " + Sexp.to_string(args)))
                ]
              };
      }
      var op = head._0[1];
      switch (op) {
        case "1" :
            return {
                    TAG: /* RunOk */2,
                    _0: args
                  };
        case "10" :
            if (args.TAG === /* Cons */1) {
              var match = args._0;
              var match$1 = match[2];
              if (match$1.TAG === /* Cons */1) {
                var match$2 = match$1._0;
                if (match$2[2].TAG === /* Nil */0) {
                  var b = match$2[1];
                  return runBind((function (aval) {
                                return runMap((function (param) {
                                              if (aval > param) {
                                                return {
                                                        TAG: /* Integer */2,
                                                        _0: [
                                                          l,
                                                          "1"
                                                        ]
                                                      };
                                              } else {
                                                return {
                                                        TAG: /* Nil */0,
                                                        _0: l
                                                      };
                                              }
                                            }), cvt_to_string(l, b));
                              }), cvt_to_string(l, match[1]));
                }
                
              }
              
            }
            break;
        case "11" :
            if (args.TAG === /* Cons */1) {
              var match$3 = args._0;
              if (match$3[2].TAG === /* Nil */0) {
                return runMap((function (s) {
                              var hasher = Hash.create(undefined);
                              hasher.update(s);
                              return {
                                      TAG: /* Integer */2,
                                      _0: [
                                        l,
                                        Sexp.normalize_int(hasher.hex(), 16)
                                      ]
                                    };
                            }), cvt_to_string(l, match$3[1]));
              }
              
            }
            break;
        case "12" :
            if (args.TAG === /* Cons */1) {
              var match$4 = args._0;
              var match$5 = match$4[2];
              if (match$5.TAG === /* Cons */1) {
                var match$6 = match$5._0;
                var match$7 = match$6[2];
                if (match$7.TAG === /* Cons */1) {
                  var match$8 = match$7._0;
                  if (match$8[2].TAG === /* Nil */0) {
                    var until = match$8[1];
                    var from = match$6[1];
                    return runBind((function (param) {
                                  var uval = param[2];
                                  var fromval = param[1];
                                  var str = param[0];
                                  var slen = str.length;
                                  if (fromval < 0 || fromval >= slen || uval < 0 || uval > slen || uval < fromval) {
                                    return {
                                            TAG: /* RunError */0,
                                            _0: [
                                              l,
                                              "bad range for strlen (s='" + (str + ("' f=" + (Sexp.to_string(from) + (" u=" + (Sexp.to_string(until) + ")")))))
                                            ]
                                          };
                                  } else if (fromval === uval) {
                                    return {
                                            TAG: /* RunOk */2,
                                            _0: {
                                              TAG: /* Nil */0,
                                              _0: l
                                            }
                                          };
                                  } else {
                                    return {
                                            TAG: /* RunOk */2,
                                            _0: {
                                              TAG: /* Atom */4,
                                              _0: [
                                                l,
                                                $$String.sub(str, fromval, uval - fromval | 0)
                                              ]
                                            }
                                          };
                                  }
                                }), runBind((function (sval) {
                                      return runBind((function (fromval) {
                                                    return runMap((function (uval) {
                                                                  return [
                                                                          sval,
                                                                          fromval,
                                                                          uval
                                                                        ];
                                                                }), cvt_to_int(l, until));
                                                  }), cvt_to_int(l, from));
                                    }), cvt_to_string(l, match$4[1])));
                  }
                  
                }
                
              }
              
            }
            break;
        case "13" :
            if (args.TAG === /* Cons */1) {
              var match$9 = args._0;
              if (match$9[2].TAG === /* Nil */0) {
                return runBind((function (a) {
                              return {
                                      TAG: /* RunOk */2,
                                      _0: {
                                        TAG: /* Integer */2,
                                        _0: [
                                          l,
                                          String(a.length)
                                        ]
                                      }
                                    };
                            }), cvt_to_string(l, match$9[1]));
              }
              
            }
            break;
        case "14" :
            switch (args.TAG | 0) {
              case /* Nil */0 :
                  return {
                          TAG: /* RunOk */2,
                          _0: {
                            TAG: /* Nil */0,
                            _0: l
                          }
                        };
              case /* Cons */1 :
                  var match$10 = args._0;
                  var first = match$10[1];
                  return runBind((function (cs) {
                                return runMap((function (fs) {
                                              return {
                                                      TAG: /* Atom */4,
                                                      _0: [
                                                        l,
                                                        fs + cs
                                                      ]
                                                    };
                                            }), cvt_to_string(l, first));
                              }), runBind((function (param) {
                                    return cvt_to_string(l, param);
                                  }), apply_op(l, head, match$10[2])));
              default:
                
            }
            break;
        case "16" :
            if (args.TAG === /* Cons */1) {
              var match$11 = args._0;
              var match$12 = match$11[2];
              if (match$12.TAG === /* Cons */1) {
                var match$13 = match$12._0;
                if (match$13[2].TAG === /* Nil */0) {
                  return Arith.do_arith(l, Arith.add, match$11[1], match$13[1]);
                }
                
              }
              
            }
            break;
        case "17" :
            if (args.TAG === /* Cons */1) {
              var match$14 = args._0;
              var match$15 = match$14[2];
              if (match$15.TAG === /* Cons */1) {
                var match$16 = match$15._0;
                if (match$16[2].TAG === /* Nil */0) {
                  return Arith.do_arith(l, Arith.subtract, match$14[1], match$16[1]);
                }
                
              }
              
            }
            break;
        case "18" :
            if (args.TAG === /* Cons */1) {
              var match$17 = args._0;
              var match$18 = match$17[2];
              if (match$18.TAG === /* Cons */1) {
                var match$19 = match$18._0;
                if (match$19[2].TAG === /* Nil */0) {
                  return Arith.do_arith(l, Arith.multiply, match$17[1], match$19[1]);
                }
                
              }
              
            }
            break;
        case "19" :
            if (args.TAG === /* Cons */1) {
              var match$20 = args._0;
              var match$21 = match$20[2];
              if (match$21.TAG === /* Cons */1) {
                var match$22 = match$21._0;
                if (match$22[2].TAG === /* Nil */0) {
                  return Arith.do_arith(l, Arith.divide, match$20[1], match$22[1]);
                }
                
              }
              
            }
            break;
        case "2" :
            if (args.TAG === /* Cons */1) {
              var match$23 = args._0;
              var match$24 = match$23[2];
              if (match$24.TAG === /* Cons */1) {
                var match$25 = match$24._0;
                if (match$25[2].TAG === /* Nil */0) {
                  return run(match$23[1], match$25[1]);
                }
                
              }
              
            }
            break;
        case "20" :
            if (args.TAG === /* Cons */1) {
              var match$26 = args._0;
              var match$27 = match$26[2];
              if (match$27.TAG === /* Cons */1) {
                var match$28 = match$27._0;
                if (match$28[2].TAG === /* Nil */0) {
                  return Arith.do_divmod(l, match$26[1], match$28[1]);
                }
                
              }
              
            }
            break;
        case "21" :
            if (args.TAG === /* Cons */1) {
              var match$29 = args._0;
              var match$30 = match$29[2];
              if (match$30.TAG === /* Cons */1) {
                var match$31 = match$30._0;
                if (match$31[2].TAG === /* Nil */0) {
                  return Arith.do_arith(l, Arith.do_greater, match$29[1], match$31[1]);
                }
                
              }
              
            }
            break;
        case "22" :
            if (args.TAG === /* Cons */1) {
              var match$32 = args._0;
              var match$33 = match$32[2];
              if (match$33.TAG === /* Cons */1) {
                var match$34 = match$33._0;
                if (match$34[2].TAG === /* Nil */0) {
                  return Arith.do_arith(l, Arith.ash, match$32[1], match$34[1]);
                }
                
              }
              
            }
            break;
        case "23" :
            if (args.TAG === /* Cons */1) {
              var match$35 = args._0;
              var match$36 = match$35[2];
              if (match$36.TAG === /* Cons */1) {
                var match$37 = match$36._0;
                if (match$37[2].TAG === /* Nil */0) {
                  return Arith.do_arith(l, Arith.lsh, match$35[1], match$37[1]);
                }
                
              }
              
            }
            break;
        case "24" :
            if (args.TAG === /* Cons */1) {
              var match$38 = args._0;
              var match$39 = match$38[2];
              if (match$39.TAG === /* Cons */1) {
                var match$40 = match$39._0;
                if (match$40[2].TAG === /* Nil */0) {
                  return Arith.do_arith(l, Arith.logand, match$38[1], match$40[1]);
                }
                
              }
              
            }
            break;
        case "25" :
            if (args.TAG === /* Cons */1) {
              var match$41 = args._0;
              var match$42 = match$41[2];
              if (match$42.TAG === /* Cons */1) {
                var match$43 = match$42._0;
                if (match$43[2].TAG === /* Nil */0) {
                  return Arith.do_arith(l, Arith.logior, match$41[1], match$43[1]);
                }
                
              }
              
            }
            break;
        case "26" :
            if (args.TAG === /* Cons */1) {
              var match$44 = args._0;
              var match$45 = match$44[2];
              if (match$45.TAG === /* Cons */1) {
                var match$46 = match$45._0;
                if (match$46[2].TAG === /* Nil */0) {
                  return Arith.do_arith(l, Arith.logxor, match$44[1], match$46[1]);
                }
                
              }
              
            }
            break;
        case "27" :
            if (args.TAG === /* Cons */1) {
              var match$47 = args._0;
              if (match$47[2].TAG === /* Nil */0) {
                if (Sexp.nilp(match$47[1])) {
                  return {
                          TAG: /* RunOk */2,
                          _0: {
                            TAG: /* Integer */2,
                            _0: [
                              l,
                              "1"
                            ]
                          }
                        };
                } else {
                  return {
                          TAG: /* RunOk */2,
                          _0: {
                            TAG: /* Nil */0,
                            _0: l
                          }
                        };
                }
              }
              
            }
            break;
        case "3" :
            if (args.TAG === /* Cons */1) {
              var match$48 = args._0;
              var match$49 = match$48[2];
              if (match$49.TAG === /* Cons */1) {
                var match$50 = match$49._0;
                var match$51 = match$50[2];
                if (match$51.TAG === /* Cons */1) {
                  var match$52 = match$51._0;
                  if (match$52[2].TAG === /* Nil */0) {
                    if (Sexp.nilp(match$48[1])) {
                      return {
                              TAG: /* RunOk */2,
                              _0: match$52[1]
                            };
                    } else {
                      return {
                              TAG: /* RunOk */2,
                              _0: match$50[1]
                            };
                    }
                  }
                  
                }
                
              }
              
            }
            break;
        case "32" :
            if (args.TAG === /* Cons */1) {
              var match$53 = args._0;
              if (match$53[2].TAG === /* Nil */0) {
                if (Sexp.nilp(match$53[1])) {
                  return {
                          TAG: /* RunOk */2,
                          _0: {
                            TAG: /* Integer */2,
                            _0: [
                              l,
                              "1"
                            ]
                          }
                        };
                } else {
                  return {
                          TAG: /* RunOk */2,
                          _0: {
                            TAG: /* Nil */0,
                            _0: l
                          }
                        };
                }
              }
              
            }
            break;
        case "33" :
            switch (args.TAG | 0) {
              case /* Nil */0 :
                  return {
                          TAG: /* RunOk */2,
                          _0: {
                            TAG: /* Integer */2,
                            _0: [
                              l,
                              "1"
                            ]
                          }
                        };
              case /* Cons */1 :
                  var match$54 = args._0;
                  var first$1 = match$54[1];
                  return runBind((function (rres) {
                                if (Sexp.nilp(rres) && Sexp.nilp(first$1)) {
                                  return {
                                          TAG: /* RunOk */2,
                                          _0: {
                                            TAG: /* Nil */0,
                                            _0: l
                                          }
                                        };
                                } else {
                                  return {
                                          TAG: /* RunOk */2,
                                          _0: {
                                            TAG: /* Integer */2,
                                            _0: [
                                              l,
                                              "1"
                                            ]
                                          }
                                        };
                                }
                              }), apply_op(l, head, match$54[2]));
              default:
                
            }
            break;
        case "34" :
            switch (args.TAG | 0) {
              case /* Nil */0 :
                  return {
                          TAG: /* RunOk */2,
                          _0: {
                            TAG: /* Nil */0,
                            _0: l
                          }
                        };
              case /* Cons */1 :
                  var match$55 = args._0;
                  var first$2 = match$55[1];
                  return runBind((function (rres) {
                                if (Sexp.nilp(rres) || Sexp.nilp(first$2)) {
                                  return {
                                          TAG: /* RunOk */2,
                                          _0: {
                                            TAG: /* Nil */0,
                                            _0: l
                                          }
                                        };
                                } else {
                                  return {
                                          TAG: /* RunOk */2,
                                          _0: {
                                            TAG: /* Integer */2,
                                            _0: [
                                              l,
                                              "1"
                                            ]
                                          }
                                        };
                                }
                              }), apply_op(l, head, match$55[2]));
              default:
                
            }
            break;
        case "4" :
            if (args.TAG === /* Cons */1) {
              var match$56 = args._0;
              var match$57 = match$56[2];
              if (match$57.TAG === /* Cons */1) {
                var match$58 = match$57._0;
                if (match$58[2].TAG === /* Nil */0) {
                  return {
                          TAG: /* RunOk */2,
                          _0: {
                            TAG: /* Cons */1,
                            _0: [
                              l,
                              match$56[1],
                              match$58[1]
                            ]
                          }
                        };
                }
                
              }
              
            }
            break;
        case "5" :
            if (args.TAG === /* Cons */1) {
              var match$59 = args._0;
              if (match$59[2].TAG === /* Nil */0) {
                var lst = match$59[1];
                if (lst.TAG === /* Cons */1) {
                  return {
                          TAG: /* RunOk */2,
                          _0: lst._0[1]
                        };
                } else {
                  return {
                          TAG: /* RunError */0,
                          _0: [
                            l,
                            "first applied to " + Sexp.to_string(lst)
                          ]
                        };
                }
              }
              
            }
            break;
        case "6" :
            if (args.TAG === /* Cons */1) {
              var match$60 = args._0;
              if (match$60[2].TAG === /* Nil */0) {
                var lst$1 = match$60[1];
                if (lst$1.TAG === /* Cons */1) {
                  return {
                          TAG: /* RunOk */2,
                          _0: lst$1._0[2]
                        };
                } else {
                  return {
                          TAG: /* RunError */0,
                          _0: [
                            l,
                            "rest applied to " + Sexp.to_string(lst$1)
                          ]
                        };
                }
              }
              
            }
            break;
        case "7" :
            if (args.TAG === /* Cons */1) {
              var match$61 = args._0;
              if (match$61[2].TAG === /* Nil */0) {
                if (match$61[1].TAG === /* Cons */1) {
                  return {
                          TAG: /* RunOk */2,
                          _0: {
                            TAG: /* Integer */2,
                            _0: [
                              l,
                              "1"
                            ]
                          }
                        };
                } else {
                  return {
                          TAG: /* RunOk */2,
                          _0: {
                            TAG: /* Nil */0,
                            _0: l
                          }
                        };
                }
              }
              
            }
            break;
        case "8" :
            return {
                    TAG: /* RunExn */1,
                    _0: [
                      l,
                      args
                    ]
                  };
        case "9" :
            if (args.TAG === /* Cons */1) {
              var match$62 = args._0;
              var match$63 = match$62[2];
              if (match$63.TAG === /* Cons */1) {
                var match$64 = match$63._0;
                if (match$64[2].TAG === /* Nil */0) {
                  if (Sexp.equal(match$62[1], match$64[1])) {
                    return {
                            TAG: /* RunOk */2,
                            _0: {
                              TAG: /* Integer */2,
                              _0: [
                                l,
                                "1"
                              ]
                            }
                          };
                  } else {
                    return {
                            TAG: /* RunOk */2,
                            _0: {
                              TAG: /* Nil */0,
                              _0: l
                            }
                          };
                  }
                }
                
              }
              
            }
            break;
        default:
          
      }
      return {
              TAG: /* RunError */0,
              _0: [
                l,
                "bad arguments to op " + op
              ]
            };
    };
    switch (sexp.TAG | 0) {
      case /* Nil */0 :
          return {
                  TAG: /* RunOk */2,
                  _0: {
                    TAG: /* Nil */0,
                    _0: sexp._0
                  }
                };
      case /* Cons */1 :
          var match = sexp._0;
          var b = match[2];
          var l = match[0];
          return runBind((function(l,b){
                    return function (head) {
                      if (head.TAG === /* Integer */2) {
                        if (head._0[1] === "1") {
                          return {
                                  TAG: /* RunOk */2,
                                  _0: b
                                };
                        } else {
                          return runBind((function (param) {
                                        return apply_op(l, head, param);
                                      }), eval_args(b));
                        }
                      } else {
                        return runBind((function (param) {
                                      return apply_op(l, head, param);
                                    }), eval_args(b));
                      }
                    }
                    }(l,b)), translate_head(match[1]));
      case /* Integer */2 :
          var match$1 = sexp._0;
          var v = match$1[1];
          return choose_path(match$1[0], Sexp.intval(v), Sexp.intval(v), context, context);
      case /* QuotedString */3 :
          return {
                  TAG: /* RunOk */2,
                  _0: sexp
                };
      case /* Atom */4 :
          var match$2 = sexp._0;
          _sexp = {
            TAG: /* Integer */2,
            _0: [
              match$2[0],
              Sexp.encode_string_to_bigint(match$2[1])
            ]
          };
          continue ;
      
    }
  };
}

function parse_and_run(file, content, args) {
  var parse_result = Sexp.parse_sexp(Srcloc.combineSrcLocation, Srcloc.start(file), Srcloc.advance)(content);
  var parse_args = Sexp.parse_sexp(Srcloc.combineSrcLocation, Srcloc.start(file), Srcloc.advance)(args);
  if (parse_result.TAG === /* Success */0) {
    var code = parse_result._0;
    if (parse_args.TAG === /* Success */0) {
      var args$1 = parse_args._0;
      if (code) {
        if (args$1) {
          return run(code.hd, args$1.hd);
        } else {
          return {
                  TAG: /* RunError */0,
                  _0: [
                    Srcloc.start(file),
                    "no args"
                  ]
                };
        }
      } else {
        return {
                TAG: /* RunError */0,
                _0: [
                  Srcloc.start(file),
                  "no code"
                ]
              };
      }
    }
    
  }
  if (parse_args.TAG === /* Success */0) {
    var match = parse_result._0;
    return {
            TAG: /* RunError */0,
            _0: [
              match[0],
              match[1]
            ]
          };
  }
  var match$1 = parse_args._0;
  return {
          TAG: /* RunError */0,
          _0: [
            match$1[0],
            match$1[1]
          ]
        };
}

exports.choose_path = choose_path;
exports.runMap = runMap;
exports.runBind = runBind;
exports.cvt_to_string = cvt_to_string;
exports.cvt_to_int = cvt_to_int;
exports.run = run;
exports.parse_and_run = parse_and_run;
/* Hash Not a pure module */
