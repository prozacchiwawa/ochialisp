// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function srcLocationToJson(sl) {
  var b_0 = [
    "line",
    sl.line
  ];
  var b_1 = {
    hd: [
      "col",
      sl.col
    ],
    tl: /* [] */0
  };
  var b = {
    hd: b_0,
    tl: b_1
  };
  var match = sl.until;
  var u = match !== undefined ? ({
        hd: [
          "ml",
          match[0]
        ],
        tl: {
          hd: [
            "mc",
            match[1]
          ],
          tl: /* [] */0
        }
      }) : /* [] */0;
  return Js_dict.fromList(List.concat({
                  hd: b,
                  tl: {
                    hd: u,
                    tl: /* [] */0
                  }
                }));
}

function toString(a) {
  var match = a.until;
  if (match !== undefined) {
    return Curry._6(Printf.sprintf(/* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* Char_literal */12,
                        _0: /* '(' */40,
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String_literal */11,
                            _0: "):",
                            _1: {
                              TAG: /* Int */4,
                              _0: /* Int_d */0,
                              _1: /* No_padding */0,
                              _2: /* No_precision */0,
                              _3: {
                                TAG: /* Char_literal */12,
                                _0: /* '-' */45,
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* Char_literal */12,
                                    _0: /* '(' */40,
                                    _1: {
                                      TAG: /* Int */4,
                                      _0: /* Int_d */0,
                                      _1: /* No_padding */0,
                                      _2: /* No_precision */0,
                                      _3: {
                                        TAG: /* String_literal */11,
                                        _0: "):",
                                        _1: {
                                          TAG: /* Int */4,
                                          _0: /* Int_d */0,
                                          _1: /* No_padding */0,
                                          _2: /* No_precision */0,
                                          _3: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "%s(%d):%d-%s(%d):%d"
                  }), a.file, a.line, a.col, a.file, match[0], match[1]);
  } else {
    return Curry._3(Printf.sprintf(/* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* Char_literal */12,
                        _0: /* '(' */40,
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String_literal */11,
                            _0: "):",
                            _1: {
                              TAG: /* Int */4,
                              _0: /* Int_d */0,
                              _1: /* No_padding */0,
                              _2: /* No_precision */0,
                              _3: /* End_of_format */0
                            }
                          }
                        }
                      }
                    },
                    _1: "%s(%d):%d"
                  }), a.file, a.line, a.col);
  }
}

function srcLocationMin(a) {
  return [
          a.line,
          a.col
        ];
}

function srcLocationMax(a) {
  var match = a.until;
  if (match !== undefined) {
    return [
            match[0],
            match[1]
          ];
  } else {
    return [
            a.line,
            a.col + 1 | 0
          ];
  }
}

function combineSrcLocation(a, b) {
  var addOnto = function (x, y) {
    return {
            file: x.file,
            line: x.line,
            col: x.col,
            until: srcLocationMax(y)
          };
  };
  if (a.line < b.line) {
    return addOnto(a, b);
  } else if (a.line === b.line) {
    if (a.col < b.col) {
      return addOnto(a, b);
    } else if (a.col === b.col) {
      return a;
    } else {
      return addOnto(b, a);
    }
  } else {
    return addOnto(b, a);
  }
}

function start(file) {
  return {
          file: file,
          line: 1,
          col: 1,
          until: undefined
        };
}

function advance(loc, param) {
  if (param !== 9) {
    if (param !== 10) {
      return {
              file: loc.file,
              line: loc.line,
              col: loc.col + 1 | 0,
              until: loc.until
            };
    } else {
      return {
              file: loc.file,
              line: loc.line + 1 | 0,
              col: 1,
              until: loc.until
            };
    }
  }
  var nextTab = loc.col + 8 & Pervasives.lnot(7);
  return {
          file: loc.file,
          line: loc.line,
          col: nextTab,
          until: loc.until
        };
}

exports.srcLocationToJson = srcLocationToJson;
exports.toString = toString;
exports.srcLocationMin = srcLocationMin;
exports.srcLocationMax = srcLocationMax;
exports.combineSrcLocation = combineSrcLocation;
exports.start = start;
exports.advance = advance;
/* No side effect */
