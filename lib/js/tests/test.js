// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Process = require("process");
var Testspec = require("./testspec.js");

var clvm_tests = {
  hd: {
    expected: {
      TAG: /* RunOk */2,
      _0: "(\"there\" \"fool\")"
    },
    input: "(a (q 2 4 (c 2 (c 6 ()))) (c (q 13 26729 \"there\" \"fool\") 1))",
    args: "()"
  },
  tl: {
    hd: {
      expected: {
        TAG: /* RunOk */2,
        _0: "(4 1 (4 2 ()))"
      },
      input: "(a (q 2 (q 2 2 (c 2 (c 3 (q)))) (c (q 2 (i 5 (q 4 (q . 4) (c 9 (c (a 2 (c 2 (c 13 (q)))) (q)))) (q 1)) 1) 1)) 1)",
      args: "(1 2)"
    },
    tl: {
      hd: {
        expected: {
          TAG: /* RunOk */2,
          _0: "13"
        },
        input: "(2 (3 (1) (1 16 (1 . 1) (1 . 3)) (1 16 (1 . 5) (1 . 8))) 1)",
        args: "()"
      },
      tl: /* [] */0
    }
  }
};

var compile_tests_0 = {
  expected: {
    TAG: /* CompileOk */0,
    _0: "(2 (1 16 (1 . 1) (1 . 3)) (4 (1) 1))"
  },
  opts: {
    includeDirs: Testspec.emptyOpts.includeDirs,
    filename: Testspec.emptyOpts.filename,
    readNewFile: Testspec.emptyOpts.readNewFile,
    compiler: Testspec.emptyOpts.compiler,
    compileProgram: Testspec.emptyOpts.compileProgram,
    inDefun: Testspec.emptyOpts.inDefun,
    assemble: false,
    stdenv: Testspec.emptyOpts.stdenv,
    startEnv: Testspec.emptyOpts.startEnv
  },
  input: "(mod () (defmacro testmacro (A) (qq (+ 1 (unquote A)))) (testmacro 3))"
};

var compile_tests_1 = {
  hd: {
    expected: {
      TAG: /* CompileOk */0,
      _0: "(2 (1 2 (3 (1) (1 2 (1 16 (1 . 1) (1 . 3)) 1) (1 2 (1 16 (1 . 5) (1 . 8)) 1)) 1) (4 (1) 1))"
    },
    opts: {
      includeDirs: Testspec.emptyOpts.includeDirs,
      filename: Testspec.emptyOpts.filename,
      readNewFile: Testspec.emptyOpts.readNewFile,
      compiler: Testspec.emptyOpts.compiler,
      compileProgram: Testspec.emptyOpts.compileProgram,
      inDefun: Testspec.emptyOpts.inDefun,
      assemble: false,
      stdenv: false,
      startEnv: Testspec.emptyOpts.startEnv
    },
    input: "(mod () (defmacro if (A B C) (qq (a (i (unquote A) (com (unquote B)) (com (unquote C))) @))) (if () (+ 1 3) (+ 5 8)))"
  },
  tl: {
    hd: {
      expected: {
        TAG: /* CompileOk */0,
        _0: "(2 (1 2 (3 (1) (1 2 (1 16 (1 . 1) (1 . 3)) 1) (1 2 (1 16 (1 . 5) (1 . 8)) 1)) 1) (4 (1) 1))"
      },
      opts: {
        includeDirs: Testspec.emptyOpts.includeDirs,
        filename: Testspec.emptyOpts.filename,
        readNewFile: Testspec.emptyOpts.readNewFile,
        compiler: Testspec.emptyOpts.compiler,
        compileProgram: Testspec.emptyOpts.compileProgram,
        inDefun: Testspec.emptyOpts.inDefun,
        assemble: false,
        stdenv: Testspec.emptyOpts.stdenv,
        startEnv: Testspec.emptyOpts.startEnv
      },
      input: "(mod () (if () (+ 1 3) (+ 5 8)))"
    },
    tl: {
      hd: {
        expected: {
          TAG: /* CompileOk */0,
          _0: "(2 (1 2 2 (4 2 (4 (1 . 3) ()))) (4 (1 2 (1 16 5 (1 . 1)) 1) 1))"
        },
        opts: {
          includeDirs: Testspec.emptyOpts.includeDirs,
          filename: Testspec.emptyOpts.filename,
          readNewFile: Testspec.emptyOpts.readNewFile,
          compiler: Testspec.emptyOpts.compiler,
          compileProgram: Testspec.emptyOpts.compileProgram,
          inDefun: Testspec.emptyOpts.inDefun,
          assemble: false,
          stdenv: Testspec.emptyOpts.stdenv,
          startEnv: Testspec.emptyOpts.startEnv
        },
        input: "(mod () (defun f (a) (+ a 1)) (f 3))"
      },
      tl: {
        hd: {
          expected: {
            TAG: /* CompileOk */0,
            _0: "(2 (1 2 2 (4 2 (4 (1 . 3) (4 (1 . 1) ())))) (4 (1 2 (1 16 (18 5 5) 11) 1) 1))"
          },
          opts: {
            includeDirs: Testspec.emptyOpts.includeDirs,
            filename: Testspec.emptyOpts.filename,
            readNewFile: Testspec.emptyOpts.readNewFile,
            compiler: Testspec.emptyOpts.compiler,
            compileProgram: Testspec.emptyOpts.compileProgram,
            inDefun: Testspec.emptyOpts.inDefun,
            assemble: false,
            stdenv: Testspec.emptyOpts.stdenv,
            startEnv: Testspec.emptyOpts.startEnv
          },
          input: "(mod () (defun f (a b) (+ (* a a) b)) (f 3 1))"
        },
        tl: {
          hd: {
            expected: {
              TAG: /* CompileOk */0,
              _0: "(2 (1 2 2 (4 2 (4 5 ()))) (4 (1 2 (1 2 (3 (9 5 (1 . 1)) (1 2 (1 1 . 1) 1) (1 2 (1 18 (2 2 (4 2 (4 (17 5 (1 . 1)) ()))) 5) 1)) 1) 1) 1))"
            },
            opts: {
              includeDirs: Testspec.emptyOpts.includeDirs,
              filename: Testspec.emptyOpts.filename,
              readNewFile: Testspec.emptyOpts.readNewFile,
              compiler: Testspec.emptyOpts.compiler,
              compileProgram: Testspec.emptyOpts.compileProgram,
              inDefun: Testspec.emptyOpts.inDefun,
              assemble: false,
              stdenv: Testspec.emptyOpts.stdenv,
              startEnv: Testspec.emptyOpts.startEnv
            },
            input: "(mod (arg_one) (defun factorial (input) (if (= input 1) 1 (* (factorial (- input 1)) input))) (factorial arg_one))"
          },
          tl: {
            hd: {
              expected: {
                TAG: /* CompileOk */0,
                _0: "(2 (1 2 2 (4 2 (4 (1 1 2 3) ()))) (4 (1 2 (1 2 (3 5 (1 2 (1 4 (1 . 4) (4 (5 5) (4 (2 2 (4 2 (4 (6 5) ()))) (1)))) 1) (1 2 (1 1) 1)) 1) 1) 1))"
              },
              opts: {
                includeDirs: Testspec.emptyOpts.includeDirs,
                filename: Testspec.emptyOpts.filename,
                readNewFile: Testspec.emptyOpts.readNewFile,
                compiler: Testspec.emptyOpts.compiler,
                compileProgram: Testspec.emptyOpts.compileProgram,
                inDefun: Testspec.emptyOpts.inDefun,
                assemble: false,
                stdenv: Testspec.emptyOpts.stdenv,
                startEnv: Testspec.emptyOpts.startEnv
              },
              input: "(mod () (defun makelist (a) (if a (c (q . 4) (c (f a) (c (makelist (r a)) (q . ())))) (q . ()))) (makelist (q . (1 2 3))))"
            },
            tl: /* [] */0
          }
        }
      }
    }
  }
};

var compile_tests = {
  hd: compile_tests_0,
  tl: compile_tests_1
};

var full_tests_0 = {
  expected: {
    TAG: /* RunOk */2,
    _0: "10"
  },
  input: "(mod () (defun f (a b) (+ (* a a) b)) (f 3 1))",
  opts: {
    includeDirs: Testspec.emptyOpts.includeDirs,
    filename: Testspec.emptyOpts.filename,
    readNewFile: Testspec.emptyOpts.readNewFile,
    compiler: Testspec.emptyOpts.compiler,
    compileProgram: Testspec.emptyOpts.compileProgram,
    inDefun: Testspec.emptyOpts.inDefun,
    assemble: false,
    stdenv: Testspec.emptyOpts.stdenv,
    startEnv: Testspec.emptyOpts.startEnv
  },
  args: "()"
};

var full_tests_1 = {
  hd: {
    expected: {
      TAG: /* RunOk */2,
      _0: "13"
    },
    input: "(mod (c) (defun f (a b) (+ (* a a) b)) (f 3 c))",
    opts: {
      includeDirs: Testspec.emptyOpts.includeDirs,
      filename: Testspec.emptyOpts.filename,
      readNewFile: Testspec.emptyOpts.readNewFile,
      compiler: Testspec.emptyOpts.compiler,
      compileProgram: Testspec.emptyOpts.compileProgram,
      inDefun: Testspec.emptyOpts.inDefun,
      assemble: false,
      stdenv: Testspec.emptyOpts.stdenv,
      startEnv: Testspec.emptyOpts.startEnv
    },
    args: "(4)"
  },
  tl: {
    hd: {
      expected: {
        TAG: /* RunOk */2,
        _0: "120"
      },
      input: "(mod (arg_one) (defun factorial (input) (if (= input 1) 1 (* (factorial (- input 1)) input))) (factorial arg_one))",
      opts: {
        includeDirs: Testspec.emptyOpts.includeDirs,
        filename: Testspec.emptyOpts.filename,
        readNewFile: Testspec.emptyOpts.readNewFile,
        compiler: Testspec.emptyOpts.compiler,
        compileProgram: Testspec.emptyOpts.compileProgram,
        inDefun: Testspec.emptyOpts.inDefun,
        assemble: false,
        stdenv: Testspec.emptyOpts.stdenv,
        startEnv: Testspec.emptyOpts.startEnv
      },
      args: "(5)"
    },
    tl: {
      hd: {
        expected: {
          TAG: /* RunOk */2,
          _0: "(4 1 (4 2 (4 3 ())))"
        },
        input: "(mod () (defun makelist (a) (if a (c (q . 4) (c (f a) (c (makelist (r a)) (q . ())))) (q . ()))) (makelist (q . (1 2 3))))",
        opts: {
          includeDirs: Testspec.emptyOpts.includeDirs,
          filename: Testspec.emptyOpts.filename,
          readNewFile: Testspec.emptyOpts.readNewFile,
          compiler: Testspec.emptyOpts.compiler,
          compileProgram: Testspec.emptyOpts.compileProgram,
          inDefun: Testspec.emptyOpts.inDefun,
          assemble: false,
          stdenv: Testspec.emptyOpts.stdenv,
          startEnv: Testspec.emptyOpts.startEnv
        },
        args: "()"
      },
      tl: {
        hd: {
          expected: {
            TAG: /* RunOk */2,
            _0: "(1 2)"
          },
          input: "(mod (a) (list 1 2))",
          opts: {
            includeDirs: Testspec.emptyOpts.includeDirs,
            filename: Testspec.emptyOpts.filename,
            readNewFile: Testspec.emptyOpts.readNewFile,
            compiler: Testspec.emptyOpts.compiler,
            compileProgram: Testspec.emptyOpts.compileProgram,
            inDefun: Testspec.emptyOpts.inDefun,
            assemble: false,
            stdenv: Testspec.emptyOpts.stdenv,
            startEnv: Testspec.emptyOpts.startEnv
          },
          args: "()"
        },
        tl: {
          hd: {
            expected: {
              TAG: /* RunOk */2,
              _0: "(100 81 64 49)"
            },
            input: "(mod args (defmacro square (input) (qq (* (unquote input) (unquote input)))) (defun sqre_list (my_list) (if my_list (c (square (f my_list)) (sqre_list (r my_list))) my_list)) (sqre_list args))",
            opts: {
              includeDirs: Testspec.emptyOpts.includeDirs,
              filename: Testspec.emptyOpts.filename,
              readNewFile: Testspec.emptyOpts.readNewFile,
              compiler: Testspec.emptyOpts.compiler,
              compileProgram: Testspec.emptyOpts.compileProgram,
              inDefun: Testspec.emptyOpts.inDefun,
              assemble: false,
              stdenv: Testspec.emptyOpts.stdenv,
              startEnv: Testspec.emptyOpts.startEnv
            },
            args: "(10 9 8 7)"
          },
          tl: {
            hd: {
              expected: {
                TAG: /* RunOk */2,
                _0: "((51 305419896 1000000000))"
              },
              input: "(mod (PASSWORD_HASH password new_puzhash amount) (defconstant CREATE_COIN 51) (defun check_password (PASSWORD_HASH password new_puzhash amount) (if (= (sha256 password) PASSWORD_HASH) (list (list CREATE_COIN new_puzhash amount)) (x))) (check_password PASSWORD_HASH password new_puzhash amount))",
              opts: {
                includeDirs: Testspec.emptyOpts.includeDirs,
                filename: Testspec.emptyOpts.filename,
                readNewFile: Testspec.emptyOpts.readNewFile,
                compiler: Testspec.emptyOpts.compiler,
                compileProgram: Testspec.emptyOpts.compileProgram,
                inDefun: Testspec.emptyOpts.inDefun,
                assemble: false,
                stdenv: Testspec.emptyOpts.stdenv,
                startEnv: Testspec.emptyOpts.startEnv
              },
              args: "(0x2ac6aecf15ac3042db34af4863da46111da7e1bf238fc13da1094f7edc8972a1 \"sha256ftw\" 0x12345678 1000000000)"
            },
            tl: /* [] */0
          }
        }
      }
    }
  }
};

var full_tests = {
  hd: full_tests_0,
  tl: full_tests_1
};

var failed = {
  contents: false
};

List.iteri((function (param, param$1) {
        return Testspec.RunExecTest.run(failed, param, param$1);
      }), clvm_tests);

List.iteri((function (param, param$1) {
        return Testspec.RunCompileTest.run(failed, param, param$1);
      }), compile_tests);

List.iteri((function (param, param$1) {
        return Testspec.RunFullTest.run(failed, param, param$1);
      }), full_tests);

setTimeout((function (param) {
        if (failed.contents) {
          console.log("\nTests FAILED\n");
          return Process.abort();
        } else {
          console.log("\nTests PASSED\n");
          return ;
        }
      }), 500);

exports.clvm_tests = clvm_tests;
exports.compile_tests = compile_tests;
exports.full_tests = full_tests;
/*  Not a pure module */
