// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Clvm = require("../src/clvm.js");
var Sexp = require("../src/sexp.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Macros = require("../src/macros.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Srcloc = require("../src/srcloc.js");
var $$String = require("bs-platform/lib/js/string.js");
var Codegen = require("../src/codegen.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Compiler = require("../src/compiler.js");
var Frontend = require("../src/frontend.js");
var Runtypes = require("../src/runtypes.js");
var Comptypes = require("../src/comptypes.js");

function emptyOpts_readNewFile(param, param$1, name) {
  if (name === "*macros*") {
    return {
            TAG: /* CompileOk */0,
            _0: [
              name,
              $$String.concat("\n", Macros.macros)
            ]
          };
  } else {
    return {
            TAG: /* CompileError */1,
            _0: Srcloc.start(name),
            _1: "include unimplemented for name " + name
          };
  }
}

function emptyOpts_compileProgram(opts, program) {
  return Comptypes.compBind((function (m) {
                return Codegen.codegen(opts, m);
              }), Frontend.frontend(opts, {
                  hd: program,
                  tl: /* [] */0
                }));
}

var emptyOpts = {
  includeDirs: /* [] */0,
  filename: "test.clvm",
  readNewFile: emptyOpts_readNewFile,
  compiler: undefined,
  compileProgram: emptyOpts_compileProgram,
  inDefun: false,
  assemble: true,
  stdenv: true,
  startEnv: undefined
};

var emptyCompile_readNewFile = emptyOpts_readNewFile;

var emptyCompile_compileProgram = emptyOpts_compileProgram;

var emptyCompile = {
  includeDirs: /* [] */0,
  filename: "test.clvm",
  readNewFile: emptyCompile_readNewFile,
  compiler: undefined,
  compileProgram: emptyCompile_compileProgram,
  inDefun: false,
  assemble: true,
  stdenv: true,
  startEnv: undefined
};

function get_expected(e) {
  return e.expected;
}

function show_failure(e, cr) {
  console.log("\nunexpected output:");
  console.log(cr);
  console.log("for input:");
  console.log(e.input);
  console.log("wanted:");
  console.log(e.expected);
  
}

function get_result(e) {
  return Compiler.compile_file(e.opts, e.input);
}

var CompileSpecT = {
  get_expected: get_expected,
  show_failure: show_failure,
  get_result: get_result
};

function get_expected$1(e) {
  return e.expected;
}

function show_failure$1(e, cr) {
  console.log("\nunexpected output:");
  console.log(Runtypes.run_to_string(Comptypes.identity, cr));
  console.log("for input:");
  console.log(e.input + (" on " + e.args));
  console.log("wanted:");
  console.log(Runtypes.run_to_string(Comptypes.identity, e.expected));
  
}

function get_result$1(e) {
  return Clvm.runMap(Sexp.to_string, Clvm.parse_and_run("*clvm*", e.input, e.args));
}

var RunSpecT = {
  get_expected: get_expected$1,
  show_failure: show_failure$1,
  get_result: get_result$1
};

function get_expected$2(e) {
  return e.expected;
}

function show_failure$2(e, cr) {
  console.log("\nunexpected output:");
  console.log(Runtypes.run_to_string(Comptypes.identity, cr));
  console.log("for input: ");
  console.log(e.input);
  console.log("with args: ");
  console.log(e.args);
  console.log("wanted:");
  console.log(Runtypes.run_to_string(Comptypes.identity, e.expected));
  
}

function get_result$2(e) {
  var compiled = Compiler.compile_file(e.opts, e.input);
  if (compiled.TAG === /* CompileOk */0) {
    return Clvm.runMap(Sexp.to_string, Clvm.parse_and_run("*clvm*", compiled._0, e.args));
  } else {
    return {
            TAG: /* RunError */0,
            _0: [
              compiled._0,
              "compile: " + compiled._1
            ]
          };
  }
}

var FullSpecT = {
  get_expected: get_expected$2,
  show_failure: show_failure$2,
  get_result: get_result$2
};

function RunTest(Test) {
  var run = function (failed, i, e) {
    var cr = Curry._1(Test.get_result, e);
    if (Caml_obj.caml_notequal(cr, Curry._1(Test.get_expected, e))) {
      failed.contents = true;
      return Curry._2(Test.show_failure, e, cr);
    } else {
      return Curry._1(Printf.printf(/* Format */{
                      _0: {
                        TAG: /* Char_literal */12,
                        _0: /* '\r' */13,
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* Char_literal */12,
                            _0: /* '\r' */13,
                            _1: /* End_of_format */0
                          }
                        }
                      },
                      _1: "\r%s\r"
                    }), String(i));
    }
  };
  return {
          run: run
        };
}

function run(failed, i, e) {
  var cr = get_result$1(e);
  if (Caml_obj.caml_notequal(cr, e.expected)) {
    failed.contents = true;
    return show_failure$1(e, cr);
  } else {
    return Curry._1(Printf.printf(/* Format */{
                    _0: {
                      TAG: /* Char_literal */12,
                      _0: /* '\r' */13,
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* Char_literal */12,
                          _0: /* '\r' */13,
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "\r%s\r"
                  }), String(i));
  }
}

var RunExecTest = {
  run: run
};

function run$1(failed, i, e) {
  var cr = get_result(e);
  if (Caml_obj.caml_notequal(cr, e.expected)) {
    failed.contents = true;
    return show_failure(e, cr);
  } else {
    return Curry._1(Printf.printf(/* Format */{
                    _0: {
                      TAG: /* Char_literal */12,
                      _0: /* '\r' */13,
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* Char_literal */12,
                          _0: /* '\r' */13,
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "\r%s\r"
                  }), String(i));
  }
}

var RunCompileTest = {
  run: run$1
};

function run$2(failed, i, e) {
  var cr = get_result$2(e);
  if (Caml_obj.caml_notequal(cr, e.expected)) {
    failed.contents = true;
    return show_failure$2(e, cr);
  } else {
    return Curry._1(Printf.printf(/* Format */{
                    _0: {
                      TAG: /* Char_literal */12,
                      _0: /* '\r' */13,
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* Char_literal */12,
                          _0: /* '\r' */13,
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "\r%s\r"
                  }), String(i));
  }
}

var RunFullTest = {
  run: run$2
};

exports.emptyOpts = emptyOpts;
exports.emptyCompile = emptyCompile;
exports.CompileSpecT = CompileSpecT;
exports.RunSpecT = RunSpecT;
exports.FullSpecT = FullSpecT;
exports.RunTest = RunTest;
exports.RunExecTest = RunExecTest;
exports.RunCompileTest = RunCompileTest;
exports.RunFullTest = RunFullTest;
/* Clvm Not a pure module */
